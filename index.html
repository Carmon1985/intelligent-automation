<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDS Intelligent Automation Team</title>
  <style>
	
	/* Mobile Optimization Styles */
@media (max-width: 768px) {
  /* General layout improvements */
  body {
    font-size: 14px;
  }
  
  .container {
    padding: 10px;
  }
  
  header {
    flex-direction: column;
    align-items: center;
    padding: 10px 0;
  }
  
  nav ul {
    margin-top: 10px;
    justify-content: center;
  }
  
  nav ul li {
    margin: 0 10px;
  }
  
  /* Improve maze container sizing */
  #mazeContainer {
    width: 100% !important;
    height: 350px !important;
    max-width: none;
  }
  
  /* Improve control panel layout */
  .controls-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .standard-controls, .advanced-controls, 
  .process-load-container, .process-metrics-container, 
  .process-objectives-container {
    padding: 10px;
  }
  
  /* Improve KPI grid for smaller screens */
  .kpi-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
  
  .kpi-item {
    padding: 8px;
  }
  
  .kpi-label {
    font-size: 12px;
  }
  
  .kpi-value {
    font-size: 14px;
  }
  
  /* Improve sliders for touch */
  .slider {
    height: 30px;
    margin: 15px 0;
  }
  
  .slider::-webkit-slider-thumb {
    width: 30px;
    height: 30px;
  }
  
  /* Make buttons more tappable */
  #clearButton, #restartButton {
    padding: 15px;
    font-size: 16px;
    margin: 15px 0;
  }
  
  /* Improve section headers */
  .section-header {
    padding: 12px;
  }
  
  /* Improve business message for mobile */
  .business-message {
    font-size: 14px;
    padding: 8px 12px;
  }
  
  /* Fix convai widget size */
  .convai-wrapper {
    margin-top: 30px;
    width: 100%;
  }
  
  elevenlabs-convai {
    width: 100% !important;
  }
  
  /* Tooltip enhancements for mobile */
  #tooltip {
    font-size: 12px;
    padding: 8px;
    max-width: 80%;
  }
}

/* Landscape mode optimizations */
@media (max-width: 900px) and (orientation: landscape) {
  .game-control-wrapper {
    grid-template-columns: 1fr 1fr;
    grid-template-areas: 
      "maze controls"
      "process process";
  }
  
  #mazeContainer {
    height: 250px !important;
  }
  
  .kpi-grid {
    grid-template-columns: repeat(4, 1fr);
  }
  
  .convai-wrapper {
    display: none !important;
  }
}

/* Fix for very small screens */
@media (max-width: 375px) {
  .section-header h3 {
    font-size: 14px;
  }
  
  #mazeContainer {
    height: 300px !important;
  }
  
  .objective-item {
    padding: 8px;
  }
  
  .objective-text {
    font-size: 12px;
  }
  
  .convai-wrapper {
    display: none !important;
  }
}

.qr-code-container {
  position: fixed;
  bottom: 200px;
  right: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
  
.objective-status.complete {
  background-color: #50C878;
  border: 1px solid #fff;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.2); opacity: 0.7; }
  100% { transform: scale(1); opacity: 1; }
}
  
.kpi-value {
  color: white;
  font-size: 1.2rem;
  font-weight: bold;
  transition: color 0.5s;
}
  
.qr-code-inner {
  background-color: #222;
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
  text-align: center;
  border: 1px solid rgba(255, 215, 0, 0.5);
}
  
.qr-code-inner h3 {
  color: #FFD700;
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 16px;
}
  
.qr-code-inner p {
  color: #fff;
  font-size: 12px;
  margin-top: 10px;
  margin-bottom: 0;
  word-break: break-all;
}
  
#qrcode {
  padding: 10px;
  background-color: white;
  border-radius: 5px;
  display: inline-block;
}
  
/* Mobile optimization toggle button */
.mobile-toggle {
  position: fixed;
  top: 10px;
  right: 10px;
  background-color: #FFD700;
  color: #000;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1000;
  box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}
  
/* Responsive adjustments */
@media (max-width: 768px) {
  .qr-code-container {
    position: static;
    margin: 20px auto 60px auto;
  }
    
  /* Additional mobile optimizations */
  .controls-wrapper {
    padding: 0 10px;
  }
  
  .standard-controls, .advanced-controls {
    margin-bottom: 15px;
  }
  
  /* Increase tap target sizes */
  .slider {
    height: 20px;
  }
  
  .slider::-webkit-slider-thumb {
    width: 25px;
    height: 25px;
  }
  
  /* Make buttons more tappable */
  #clearButton, #restartButton {
    padding: 15px 20px;
    margin: 10px 0;
    width: 100%;
  }
  
  /* Improve mobile section headers */
  .section-header h3 {
    font-size: 16px;
  }
}

/* Main site styling */
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #000;
  color: #fff;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 20px;
  border-bottom: 1px solid rgba(255, 215, 0, 0.3);
}

.logo {
  display: flex;
  align-items: center;
  font-size: 1.5rem;
  color: #fff;
}

.logo-image {
  height: 40px;
  margin-right: 10px;
}

nav ul {
  display: flex;
  list-style: none;
  padding: 0;
}

nav ul li {
  margin-left: 20px;
}

nav ul li a {
  color: #fff;
  text-decoration: none;
}

.hero {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 40px;
  padding: 60px 0;
  align-items: center;
}

.hero-content h1 {
  font-size: 2.5rem;
  line-height: 1.2;
}

.highlight {
  color: #FFD700;
}

.hero-image img {
  width: 100%;
  border-radius: 8px;
}

.services {
  padding: 40px 0;
}

.maze-title {
  font-size: 2rem;
  color: #FFD700;
  text-align: center;
  margin-bottom: 10px;
}

.maze-description {
  text-align: center;
  max-width: 800px;
  margin: 0 auto 40px;
}

.convai-wrapper {
  margin-top: 60px;
}

/* Game styles */
.game-control-wrapper {
  display: grid;
  grid-template-columns: auto 1fr;
  grid-template-areas: 
    "maze controls"
    "process process";
  gap: 20px;
  margin: 20px auto;
  overflow: hidden; /* Prevent jumping during resize */
}

#mazeContainer {
  grid-area: maze;
  width: 530px;
  height: 570px;
  background-color: #000;
  position: relative;
  border-radius: 8px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  border: none;
  overflow: hidden;
  transition: width 0.3s ease, height 0.3s ease; /* Smooth transition */
}

/* FIXED BUTTON AND CONTROLS STYLING */
.controls-wrapper {
  grid-area: controls;
}

.controls-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-top: 15px;
}

/* Standard controls styling - fixed to prevent button overlap */
.standard-controls {
  position: static;
  padding: 15px;
  background-color: #222;
  border: none;
  border-radius: 4px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  display: flex;
  flex-direction: column;
}

.advanced-controls, .process-load-container {
  background-color: #222;
  border: none;
  padding: 15px;
  border-radius: 4px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
}

.button-container {
  margin-top: 10px;
  width: 100%;
}

#clearButton {
  width: 100%;
  background-color: #FFD700;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  color: #000;
  font-weight: bold;
  cursor: pointer;
  margin: 0;
}

.help-icon {
  background-color: #FFD700;
  color: #000;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;
  cursor: pointer;
  margin-right: 10px;
}

.help-modal {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.9);
  border: 1px solid #FFD700;
  color: #fff;
  padding: 15px;
  border-radius: 5px;
  z-index: 1000;
  max-width: 400px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
}

.help-modal h4 {
  color: #FFD700;
  margin-top: 0;
  margin-bottom: 10px;
}

.help-modal p {
  margin-bottom: 10px;
}

.help-modal ul {
  padding-left: 20px;
}

.help-modal button {
  background-color: #FFD700;
  border: none;
  color: #000;
  padding: 5px 10px;
  border-radius: 3px;
  margin-top: 10px;
  cursor: pointer;
}

.help-icon {
  background-color: #FFD700;
  color: #000;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;
  cursor: pointer;
  margin: -30px 0 10px 170px;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  padding-bottom: 8px;
  margin-bottom: 15px;
  border-bottom: 1px solid rgba(255, 215, 0, 0.3);
}

.section-header h3 {
  margin: 0;
  color: #FFD700;
  font-size: 1.2rem;
}

.main-controls-header {
  background-color: #222;
  border-radius: 4px;
  padding: 10px 15px;
  margin-bottom: 0;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  cursor: pointer;
}

.collapse-icon {
  color: #FFD700;
  transition: transform 0.3s ease;
}

.collapse-icon.collapsed {
  transform: rotate(-90deg);
}

.section-content {
  overflow: hidden;
  transition: max-height 0.3s ease;
  max-height: 500px;
  padding: 0 5px;
  margin-bottom: 10px;
}

.section-content.collapsed {
  max-height: 0;
}

h3 {
  color: #FFD700;
  margin-top: 0;
}

.control-group {
  margin-bottom: 20px;
}

.control-group:last-of-type {
  margin-bottom: 10px;
}

.control-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  color: #FFD700;
}

.control-value {
  color: white;
}

.slider {
  width: 100%;
  height: 5px;
  -webkit-appearance: none;
  background: #333;
  outline: none;
  border-radius: 3px;
  cursor: pointer;
  border: 1px solid #FFD700;
  margin: 8px 0;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 15px;
  height: 15px;
  border-radius: 50%;
  background: #FFD700;
  cursor: pointer;
}

.process-load-container {
  grid-area: process;
  margin-top: 20px;
}

.progress-bar, .wave-progress-bar {
  width: 100%;
  background: #333;
  height: 10px;
  border-radius: 5px;
  overflow: hidden;
  border: 1px solid #FFD700;
}

.progress, .wave-progress {
  height: 100%;
  background: #FFD700;
  width: 0%;
  transition: width 0.3s;
}

.wave-progress {
  width: 100%;
}

#restartButton {
  background-color: #FFD700;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  color: #000;
  font-weight: bold;
  cursor: pointer;
  margin-top: 10px;
}

#tooltip {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #FFD700;
  padding: 5px 10px;
  border-radius: 3px;
  font-size: 0.9rem;
  opacity: 1;
  display: none;
  z-index: 50;
}

/* Business message style */
.business-message {
  position: absolute;
  top: 10px;
  left: 0;
  right: 0;
  text-align: center;
  color: #FFD700;
  font-size: 1rem;
  background: rgba(0, 0, 0, 0.5);
  padding: 5px 15px;
  border-radius: 3px;
  opacity: 0;
  transition: opacity 0.5s;
  pointer-events: none;
}

#overlayMessage {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  color: #FFD700;
  font-size: clamp(1rem, 3vw, 1.8rem);
  text-align: center;
  padding: 20px;
  box-sizing: border-box;
}

#overlayMessage button {
  margin-top: clamp(10px, 2vw, 20px);
  padding: clamp(8px, 1.5vw, 15px) clamp(12px, 2vw, 20px);
  font-size: clamp(0.9rem, 1.5vw, 1.2rem);
}

/* NEW: Six Sigma KPI Styles */
.process-metrics-container,
.process-objectives-container {
  background-color: #222;
  border: none;
  padding: 15px;
  border-radius: 4px;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  margin-top: 20px;
  grid-column: span 2;
}

.kpi-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
}

.kpi-item {
  background-color: #333;
  padding: 10px;
  border-radius: 4px;
  text-align: center;
}

.kpi-label {
  color: #FFD700;
  font-size: 0.9rem;
  margin-bottom: 5px;
}

.objective-list {
  display: grid;
  gap: 10px;
}

.objective-item {
  display: flex;
  align-items: center;
  padding: 10px;
  background-color: #333;
  border-radius: 4px;
}

.objective-status {
  width: 15px;
  height: 15px;
  border-radius: 50%;
  margin-right: 10px;
}

.objective-status.incomplete {
  background-color: #666;
  border: 1px solid #999;
}

.objective-text {
  color: white;
}

/* Media query for mobile screens */
/* Media query for mobile screens */
@media (max-width: 1024px) {
  .game-control-wrapper {
    grid-template-columns: 1fr;
    grid-template-areas: 
      "maze"
      "controls"
      "process";
  }
  
  #mazeContainer {
    width: 100%;
    height: 500px;
    max-width: 500px;
    margin: 0 auto;
  }
  
  .controls-container {
    grid-template-columns: 1fr;
  }
  
  .hero {
    grid-template-columns: 1fr;
  }
  
  .kpi-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .convai-wrapper {
    display: none !important;
  }
}
    
@media (max-width: 768px) {
  .game-control-wrapper {
    grid-template-columns: 1fr;
  }
  
  .controls-container {
    grid-template-columns: 1fr;
  }
  
  #mazeContainer {
    width: 100%;
    height: 400px;
  }
  
  .convai-wrapper {
    display: none !important;
  }
}
	
  </style>
  <style id="compact-sliders">
  /* Compact text styles for sliders */
  .control-label span {
    font-size: 0.8rem !important;
  }
  
  .control-value {
    font-size: 0.8rem !important;
  }
  
  /* Make slider controls take less vertical space */
  .control-group {
    margin-bottom: 10px !important;
  }
  
  .slider {
    margin: 4px 0 !important;
  }
  
  /* Slightly reduce section header size */
  .section-header h3 {
    font-size: 1rem !important;
  }
  
  .section-header {
    margin-bottom: 10px !important;
  }
</style>
  
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <img src="LogoIA.png" alt="Logo" class="logo-image">
        GDS Intelligent Automation Team
      </div>
      <nav>
        <ul>
          <li><a href="#">Home</a></li>
          <li><a href="#">What Do We Do</a></li>
          <li><a href="#">Case Studies</a></li>
          <li><a href="#">Contact</a></li>
        </ul>
      </nav>
    </header>
    
    <section class="hero">
      <div class="hero-content">
        <h1>Transform your business with <span class="highlight">Intelligent Automation</span>: Efficiency, Innovation, and Growth at your fingertips</h1>
      </div>
      <div class="hero-image">
        <img src="lines.jpg" alt="Circuit Lines" />
      </div>
    </section>
    
    <section class="services">
      
      <!-- Maze Game Section - UPDATED TITLE/DESCRIPTION -->
     <h3 class="maze-title">Intelligent Automation Process Simulator</h3>
      
<p class="maze-description">Visualize how well-documented and standardized processes improve automation potential using RPA and Power Platform. Control dots represent automated workflows that navigate through your business processes. Your simulation starts with all metrics in the "green" state. As you adjust documentation quality, standardization level, and resource utilization with the sliders, observe how each change impacts automation potential and try to maintain optimal business outcomes.</p>
      <!-- Game Control Wrapper -->
      <div class="game-control-wrapper">
        <div id="mazeContainer">
          <div id="tooltip"></div>
          <div class="business-message" id="businessMessage"></div>
          <div id="overlayMessage">
			  Discover how our Intelligent Automation department can transform your business processes through RPA and Power Platform solutions. We help you document, standardize, and optimize your processes for maximum automation potential. Use our voice bot to contact us!
			  <button id="restartButton">Start Your Automation Journey</button>
			</div>
        </div>
        
        <div class="controls-wrapper">
          <div class="section-header main-controls-header">
            <h3>Automation Readiness Controls</h3>
            <span class="collapse-icon">▼</span>
          </div>
          <div class="controls-container">
  <!-- Standard Controls -->
  <div class="standard-controls">
    <div class="section-header">
      <h3>Process Documentation & Standardization</h3>
      <span class="collapse-icon">▼</span>
    </div>
    <div class="section-content">
      <div class="control-group">
        <div class="control-label">
          <span>Process Documentation Level</span>
          <span class="control-value" id="containerSizeValue">Standard (100%)</span>
        </div>
        <input type="range" min="450" max="800" value="570" class="slider" id="containerSizeSlider">
      </div>
      <div class="control-group">
        <div class="control-label">
          <span>Process Standardization</span>
          <span class="control-value" id="headSizeValue">Level 5</span>
        </div>
        <input type="range" min="3" max="20" value="7.5" step="0.5" class="slider" id="headSizeSlider">
      </div>
      <div class="control-group">
        <div class="control-label">
          <span>Knowledge Base Coverage</span>
          <span class="control-value" id="trailLengthValue">6M</span>
        </div>
        <input type="range" min="1000" max="8000" value="2000" step="100" class="slider" id="trailLengthSlider">
      </div>
      <div class="control-group">
        <div class="control-label">
          <span>Process Execution Rate</span>
          <span class="control-value" id="speedValue">1h</span>
        </div>
        <input type="range" min="0.5" max="8" value="2" step="0.5" class="slider" id="speedSlider">
      </div>
      <div class="control-group">
        <div class="control-label">
          <span>Workforce Capacity Allocation</span>
          <span class="control-value" id="numHeadsValue">Single Stream</span>
        </div>
        <input type="range" min="1" max="3" value="1" step="1" class="slider" id="numHeadsSlider">
      </div>
    </div>
    <div class="button-container">
      <button id="clearButton">Reset Simulation</button>
    </div>
  </div>
            
            <!-- Advanced Controls: Business Parameters -->
            <div class="advanced-controls">
              <div class="section-header">
                <h3>Operational Parameters</h3>
                <span class="collapse-icon">▼</span>
              </div>
              <div class="section-content">
                <div class="control-group">
                  <div class="control-label">
                    <span>Process Change Frequency</span>
                    <span class="control-value" id="waveFrequencyValue">Monthly</span>
                  </div>
                  <input type="range" min="0.5" max="2" value="1" step="0.1" class="slider" id="waveFrequencySlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Process Variability</span>
                    <span class="control-value" id="obstacleSizeValue">3σ</span>
                  </div>
                  <input type="range" min="20" max="80" value="40" class="slider" id="obstacleSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Exception Handling Quality</span>
                    <span class="control-value" id="obstacleSpeedValue">25%</span>
                  </div>
                  <input type="range" min="0.5" max="3.0" value="1.0" step="0.1" class="slider" id="obstacleSpeedSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Manual Intervention Rate</span>
                    <span class="control-value" id="obstaclesPerWaveValue">6,210 DPMO</span>
                  </div>
                  <input type="range" min="0.5" max="2.0" value="1.0" step="0.1" class="slider" id="obstaclesPerWaveSlider">
                </div>
                <div class="wave-countdown-container">
                  <div class="control-label">
                    <span>Automation Release Cycle</span>
                  </div>
                  <div class="wave-progress-bar">
                    <div class="wave-progress" id="waveCountdownProgress"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Process Load Tracker - UPDATED TO SIGMA LEVEL -->
        <div class="process-load-container">
          <div class="section-header">
            <h3>Automation Potential Score</h3>
            <span class="collapse-icon">▼</span>
          </div>
          <div class="section-content">
            <div class="control-label">
              <span>Process Optimization Index</span>
              <span class="control-value" id="complexityValueDisplay">0</span>
            </div>
            <div class="progress-bar">
              <div class="progress" id="complexityProgress"></div>
            </div>
            <div class="control-label">
              <span>Exception Count</span>
              <span class="control-value" id="collisionsValue">0</span>
            </div>
          </div>
        </div>
        
        <!-- NEW: Process KPIs -->
        <div class="process-metrics-container">
		  <div class="section-header">
			<h3>Automation Performance Metrics</h3>
			<span class="collapse-icon">▼</span>
		  </div>
		  <div class="section-content">
			<div class="kpi-grid">
			  <div class="kpi-item">
				<div class="kpi-label">Process Cycle Time</div>
				<div class="kpi-value" id="leadTimeValue">4.5 days</div>
			  </div>
			  <div class="kpi-item">
				<div class="kpi-label">Time Savings</div>
				<div class="kpi-value" id="valueAddedValue">23%</div>
			  </div>
			  <div class="kpi-item">
				<div class="kpi-label">Automation Complexity</div>
				<div class="kpi-value" id="sigmaLevelValue">3.2</div>
			  </div>
			  <div class="kpi-item">
				<div class="kpi-label">Process Success Rate</div>
				<div class="kpi-value" id="fttValue">82%</div>
			  </div>
			</div>
		  </div>
		</div>
        
       
        <!-- NEW: Process Objectives -->
<div class="process-objectives-container">
  <div class="section-header">
    <h3>Automation Objectives</h3>
    <div class="help-icon" id="objectivesHelpIcon" title="Click for help">?</div>
    <span class="collapse-icon">▼</span>
  </div>
  <div class="section-content">
    <div class="objective-list">
      <div class="objective-item">
        <div class="objective-status incomplete" id="objective1Status"></div>
        <div class="objective-text">Achieve 95% process documentation coverage</div>
      </div>
      <div class="objective-item">
        <div class="objective-status incomplete" id="objective2Status"></div>
        <div class="objective-text">Reach 85% standardization level</div>
      </div>
      <div class="objective-item">
        <div class="objective-status incomplete" id="objective3Status"></div>
        <div class="objective-text">Reduce manual workload by 40%</div>
      </div>
    </div>
  </div>
</div>
      
      <!-- ElevenLabs Convai Widget Container -->
      <div class="convai-wrapper">
        <elevenlabs-convai agent-id="GzXUUK45tH3zF6kwllQH"></elevenlabs-convai>
      </div>
    </section>
  </div>
  
  <!-- ElevenLabs Convai Widget Script -->
  <script src="https://elevenlabs.io/convai-widget/index.js" type="text/javascript"></script>
  
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Add QR code generator
    new QRCode(document.getElementById("qrcode"), {
      text: "https://carmon1985.github.io/intelligent-automation/",
      width: 128,
      height: 128,
      colorDark: "#000000",
      colorLight: "#ffffff",
      correctLevel: QRCode.CorrectLevel.H
    });
    
    // Add mobile toggle button
    const toggleButton = document.createElement('button');
    toggleButton.className = 'mobile-toggle';
    toggleButton.innerHTML = '<i style="font-size: 24px;">≡</i>';
    toggleButton.title = 'Toggle Controls';
    document.body.appendChild(toggleButton);
    
    // Toggle controls visibility on mobile
    toggleButton.addEventListener('click', function() {
      const controlsContainer = document.querySelector('.controls-container');
      if (controlsContainer.style.display === 'none' || controlsContainer.style.display === '') {
        controlsContainer.style.display = 'grid';
      } else {
        controlsContainer.style.display = 'none';
      }
    });
    
    // Add additional mobile optimizations
    const viewportMeta = document.querySelector('meta[name="viewport"]');
    if (viewportMeta) {
      viewportMeta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
    }
    
    // Improve touch experience for sliders
    const sliders = document.querySelectorAll('.slider');
    sliders.forEach(slider => {
      slider.addEventListener('touchstart', function(e) {
        e.stopPropagation();
      });
    });
  });
</script>
  
  <script>/**
 * LEAN SIX SIGMA PROCESS SIMULATOR
 * Main Game Script
 */

document.addEventListener('DOMContentLoaded', function() {
  // Basic setup
  const mazeContainer = document.getElementById('mazeContainer');
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size to match container
  canvas.width = mazeContainer.clientWidth;
  canvas.height = mazeContainer.clientHeight;
  mazeContainer.appendChild(canvas);
  
  // UI elements
  const containerSizeSlider = document.getElementById('containerSizeSlider');
  const headSizeSlider = document.getElementById('headSizeSlider');
  const trailLengthSlider = document.getElementById('trailLengthSlider');
  const speedSlider = document.getElementById('speedSlider');
  const numHeadsSlider = document.getElementById('numHeadsSlider');
  const waveFrequencySlider = document.getElementById('waveFrequencySlider');
  const obstacleSizeSlider = document.getElementById('obstacleSizeSlider');
  const obstacleSpeedSlider = document.getElementById('obstacleSpeedSlider');
  const obstaclesPerWaveSlider = document.getElementById('obstaclesPerWaveSlider');
  const waveCountdownProgress = document.getElementById('waveCountdownProgress');
  const clearButton = document.getElementById('clearButton');
  const restartButton = document.getElementById('restartButton');
  const tooltip = document.getElementById('tooltip');
  const businessMessage = document.getElementById('businessMessage');
  const overlayMessage = document.getElementById('overlayMessage');
  const sectionHeaders = document.querySelectorAll('.section-header');
  
  // Display elements
  const containerSizeValue = document.getElementById('containerSizeValue');
  const headSizeValue = document.getElementById('headSizeValue');
  const trailLengthValue = document.getElementById('trailLengthValue');
  const speedValue = document.getElementById('speedValue');
  const numHeadsValue = document.getElementById('numHeadsValue');
  const waveFrequencyValue = document.getElementById('waveFrequencyValue');
  const obstacleSizeValue = document.getElementById('obstacleSizeValue');
  const obstacleSpeedValue = document.getElementById('obstacleSpeedValue');
  const obstaclesPerWaveValue = document.getElementById('obstaclesPerWaveValue');
  const complexityProgress = document.getElementById('complexityProgress');
  const complexityValueDisplay = document.getElementById('complexityValueDisplay');
  const collisionsValue = document.getElementById('collisionsValue');
  const leadTimeValue = document.getElementById('leadTimeValue');
  const valueAddedValue = document.getElementById('valueAddedValue');
  const sigmaLevelValue = document.getElementById('sigmaLevelValue');
  const fttValue = document.getElementById('fttValue');
  
  // Game parameters
  let DOT_RADIUS = parseFloat(headSizeSlider.value);
  let MAX_TRAIL_LENGTH = parseInt(trailLengthSlider.value);
  let SPEED = parseFloat(speedSlider.value);
  let numHeads = parseInt(numHeadsSlider.value);
  let waveFrequencyFactor = parseFloat(waveFrequencySlider.value);
  let customObstacleSize = parseInt(obstacleSizeSlider.value);
  let customObstacleSpeed = parseFloat(obstacleSpeedSlider.value);
  let obstaclesRatio = parseFloat(obstaclesPerWaveSlider.value);
  const LINE_WIDTH = 2;
  
  let isResizing = false; // Add this with your other state variables like isGameFrozen
  
  // Game state
let heads = [];
let obstacles = [];
let staticTrails = [];
let particles = [];
let isEffectActive = false;
let collisionCount = 2; // Low initial collision count
let headCollisionCount = 0; // Separate counter for head collisions
let wallCollisionCount = 0; // Track wall collisions separately
  let headObstacleCollisions = new Set(); // To track which heads have collided with which obstacles
  let lastFrameTime = performance.now();
  let waveCountdownMax = 15000 / waveFrequencyFactor;
  let waveCountdown = waveCountdownMax;
  let messageTimeout = null;
  let controlsVisible = false;
  let isGameFrozen = false; // Add game freeze state variable
  
	  // Process KPI tracking variables with optimal starting values
	let startTime = performance.now() - 70000; // Start at 7 days for lead time
	let totalProcessed = 0;
	let valueAddedTime = 8500; // Start with high value-added time
	let totalProcessTime = 10000; // To give 85% value-added percentage
	let firstPassYield = 96; // Above 95% target
	let lastCollisionCount = 0;
  
  // Constants
  const PROCESS_LOAD_GOAL = 2000;
  let processLoadGoalReached = false;
  
  /**
   * Converts technical slider values to business-relevant terminology
   * @param {string} category - The slider category
   * @param {number} value - The raw slider value
   * @returns {string} - Business-friendly display value
   */
   
// Complete the resize operation with improved bounds handling
function completeResize(newWidth, newHeight) {
  // Update canvas dimensions
  canvas.width = newWidth;
  canvas.height = newHeight;
  
  // Reset head positions with extra care for boundaries
  heads.forEach(head => {
    // Use a larger buffer for safety
    const buffer = Math.max(5, DOT_RADIUS + 2);
    
    // Ensure position is within bounds
    head.x = Math.max(buffer, Math.min(head.x, canvas.width - buffer));
    head.y = Math.max(buffer, Math.min(head.y, canvas.height - buffer));
    
    // Reset trail to avoid visual artifacts
    head.trail = [{ x: head.x, y: head.y }];
    
    // Ensure direction vectors are reasonable
    const maxSpeed = SPEED * 1.5;
    head.dirX = Math.max(-maxSpeed, Math.min(head.dirX, maxSpeed));
    head.dirY = Math.max(-maxSpeed, Math.min(head.dirY, maxSpeed));
  });
  
  // Reset obstacles to be within bounds
  obstacles.forEach(obs => {
    obs.x = Math.max(0, Math.min(obs.x, canvas.width - obs.width));
    obs.y = Math.max(0, Math.min(obs.y, canvas.height - obs.height));
  });
  
  // Clear collision tracking to prevent false positives
  headObstacleCollisions.clear();
  
  // Force immediate redraw
  draw();
  
  // Clear resize state
  isResizing = false;
}
   
  function getBusinessValue(category, value) {
	const businessScales = {
	  containerSize: {
		scale: ['Minimal Documentation (20%)', 'Partial Documentation (40%)', 'Standard Documentation (60%)', 'Detailed Documentation (80%)', 'Comprehensive Documentation (100%)'],
		min: 450,
		max: 800
	  },
	  headSize: {
		scale: ['Ad-hoc Process (10%)', 'Partially Standardized (30%)', 'Standardized (50%)', 'Optimized (70%)', 'Fully Standardized (90%)'],
		min: 3,
		max: 20
	  },
	  trailLength: {
		scale: ['Basic KB (30%)', 'Standard KB (50%)', 'Comprehensive KB (70%)', 'Extensive KB (90%)', 'Complete KB (100%)'],
		min: 1000,
		max: 8000
	  },
	  speed: {
		scale: ['Low Velocity (20%)', 'Moderate Velocity (40%)', 'Standard Velocity (60%)', 'High Velocity (80%)', 'Optimized Velocity (100%)'],
		min: 0.5,
		max: 8
	  },
	  numHeads: {
		values: ['Available Capacity (30%)', 'Balanced Workload (60%)', 'Near Capacity (90%)']
	  },
	  waveFrequency: {
		scale: ['Quarterly', 'Bi-Monthly', 'Monthly', 'Bi-Weekly', 'Weekly', 'Daily'],
		min: 0.5,
		max: 2
	  },
	  obstacleSize: {
		scale: ['Minor Variability (10%)', 'Low Variability (25%)', 'Medium Variability (50%)', 'High Variability (75%)', 'Complex Variability (90%)'],
		min: 20,
		max: 80
	  },
	  obstacleSpeed: {
		scale: ['Rare (5%)', 'Occasional (15%)', 'Regular (25%)', 'Frequent (50%)', 'Constant (75%)'],
		min: 0.5,
		max: 3.0
	  },
	  obstaclesPerWave: {
		scale: ['Minimal Intervention (5%)', 'Low Intervention (15%)', 'Medium Intervention (30%)', 'High Intervention (50%)', 'Mostly Manual (75%)'],
		min: 0.5,
		max: 2.0
	  }
	};
    
    // Handle special case for numHeads which has discrete values
    if (category === 'numHeads') {
      return businessScales[category].values[Math.round(value) - 1];
    }
    
    // For scaled values
    const scaleInfo = businessScales[category];
    const percentage = (value - scaleInfo.min) / (scaleInfo.max - scaleInfo.min);
    const index = Math.min(Math.floor(percentage * scaleInfo.scale.length), scaleInfo.scale.length - 1);
    return scaleInfo.scale[index];
  }
  
  // Set up collapsible sections
  sectionHeaders.forEach(header => {
    if (header.classList.contains('main-controls-header')) {
      // Special handling for main controls header
      header.addEventListener('click', function() {
        const controlsContainer = document.querySelector('.controls-container');
        const icon = this.querySelector('.collapse-icon');
        
        if (controlsContainer.style.display === 'none' || controlsContainer.style.display === '') {
          controlsContainer.style.display = 'grid';
          icon.classList.remove('collapsed');
          controlsVisible = true;
        } else {
          controlsContainer.style.display = 'none';
          icon.classList.add('collapsed');
          controlsVisible = false;
        }
      });
    } else {
      // Regular section headers
      header.addEventListener('click', function() {
        const content = this.nextElementSibling;
        const icon = this.querySelector('.collapse-icon');
        
        if (content.classList.contains('collapsed')) {
          content.classList.remove('collapsed');
          icon.classList.remove('collapsed');
        } else {
          content.classList.add('collapsed');
          icon.classList.add('collapsed');
        }
      });
    }
  });
  
  // Enhanced Business Messages aligned with Lean Six Sigma concepts
  const businessMessages = {
  containerSize: {
    low: "Limited process documentation makes automation challenging. Consider documenting key process steps.",
    medium: "Process documentation at standard level, supporting basic automation initiatives.",
    high: "Comprehensive process documentation enables advanced automation opportunities.",
    increasing: "Enhancing process documentation to support more complex automation scenarios.",
    decreasing: "Focusing documentation on core process elements for targeted automation."
  },
  headSize: {
    low: "Low process standardization requires frequent human judgment for decisions.",
    medium: "Standard level of process consistency enables reliable automation development.",
    high: "High standardization level makes this process an ideal automation candidate.",
    increasing: "Improving process standardization to reduce exceptions and manual handling.",
    decreasing: "Adjusting standardization level to accommodate necessary process variations."
  },
  trailLength: {
    low: "Limited knowledge base coverage means automation will require frequent updates.",
    medium: "Adequate knowledge management supports sustainable automation solutions.",
    high: "Comprehensive knowledge base ensures automation longevity and adaptability.",
    increasing: "Expanding knowledge coverage to support broader automation capabilities.",
    decreasing: "Focusing knowledge base on most critical process elements."
  },
  speed: {
    low: "Slower execution rate allows for detailed validation but limits transaction volume.",
    medium: "Balanced execution speed supports efficient operations with adequate controls.",
    high: "Accelerated execution maximizes throughput for optimized business outcomes.",
    increasing: "Accelerating process execution to improve overall business throughput.",
    decreasing: "Moderating execution rate to ensure quality and compliance requirements."
  },
  numHeads: {
    low: "Available workforce capacity can be directed toward automation initiatives.",
    medium: "Balanced workload distribution enables stable operations with automation support.",
    high: "Workforce operating near capacity - automation can help relieve pressure.",
    increasing: "Increasing workflow demands - prioritizing automation to prevent burnout.",
    decreasing: "Redistributing workloads to focus on high-value activities."
  },
  waveFrequency: {
    low: "Extended release cycles allow for thorough testing and comprehensive feature sets.",
    medium: "Standard release frequency balances stability with innovation needs.",
    high: "Rapid deployment cycles enable quick adaptation to changing business needs.",
    increasing: "Accelerating release frequency to deliver automation improvements faster.",
    decreasing: "Extending release cycles for more comprehensive solution development."
  },
  obstacleSize: {
    low: "Minor process variability enables straightforward automation scenarios.",
    medium: "Moderate variability requires balanced exception handling capabilities.",
    high: "High variability challenges automation - consider process standardization first.",
    increasing: "Growing process complexity requires more sophisticated automation solutions.",
    decreasing: "Reducing process variability to enhance automation reliability."
  },
  obstacleSpeed: {
    low: "Infrequent exceptions allow for simpler automation design patterns.",
    medium: "Regular exceptions require standardized error handling procedures.",
    high: "Frequent exceptions demand robust exception management frameworks.",
    increasing: "Growing exception frequency may require process redesign for automation.",
    decreasing: "Reducing exception frequency through process standardization."
  },
  obstaclesPerWave: {
    low: "Minimal manual intervention enables high automation coverage.",
    medium: "Balanced human-bot collaboration required for optimal process execution.",
    high: "High manual intervention rate limits automation potential - consider process redesign.",
    increasing: "Growing manual intervention needs indicate automation design challenges.",
    decreasing: "Reducing manual touchpoints to maximize automation benefits."
  },
  process: {
    threshold1: "Automation potential approaching upper threshold - identify additional processes for automation.",
    threshold2: "Process complexity increasing - consider implementing more robust exception handling.",
    threshold3: "Process stability at risk - review documentation and standardization efforts."
  }
};
  
  // Helper function to get slider ranges for percentage calculation
  function getSliderRanges(category) {
    // Default ranges
    const ranges = {
      containerSize: { min: 450, max: 800 },
      headSize: { min: 3, max: 20 },
      trailLength: { min: 1000, max: 8000 },
      speed: { min: 0.5, max: 8 },
      numHeads: { min: 1, max: 3 },
      waveFrequency: { min: 0.5, max: 2 },
      obstacleSize: { min: 20, max: 80 },
      obstacleSpeed: { min: 0.5, max: 3.0 },
      obstaclesPerWave: { min: 0.5, max: 2.0 }
    };
    
    return ranges[category];
  }
  
  // Helper function to get slider element by category
  function getSliderByCategory(category) {
    const sliderMap = {
      containerSize: document.getElementById('containerSizeSlider'),
      headSize: document.getElementById('headSizeSlider'),
      trailLength: document.getElementById('trailLengthSlider'),
      speed: document.getElementById('speedSlider'),
      numHeads: document.getElementById('numHeadsSlider'),
      waveFrequency: document.getElementById('waveFrequencySlider'),
      obstacleSize: document.getElementById('obstacleSizeSlider'),
      obstacleSpeed: document.getElementById('obstacleSpeedSlider'),
      obstaclesPerWave: document.getElementById('obstaclesPerWaveSlider')
    };
    
    return sliderMap[category];
  }
  
  // Function to determine message based on slider value and previous value
  function getSmartBusinessMessage(category, value, oldValue) {
    // Default to medium if no old value is available
    if (oldValue === undefined) oldValue = value;
    
    // Get the range for the slider category
    const ranges = getSliderRanges(category);
    
    // Determine message type based on value and direction of change
    let messageType;
    
    // First determine the direction of change
    if (value > oldValue) {
      messageType = "increasing";
    } else if (value < oldValue) {
      messageType = "decreasing";
    } else {
      // If no change or first time, determine based on where in the range it falls
      const percentage = (value - ranges.min) / (ranges.max - ranges.min);
      
      if (percentage < 0.33) {
        messageType = "low";
      } else if (percentage < 0.66) {
        messageType = "medium";
      } else {
        messageType = "high";
      }
    }
    
    return businessMessages[category][messageType];
  }
  
  // Initialize game
  function initGame() {
    // Initialize heads
    heads = [];
    for (let i = 0; i < numHeads; i++) {
      heads.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        dirX: (Math.random() * 2 - 1) * SPEED,
        dirY: (Math.random() * 2 - 1) * SPEED,
        trail: [{ x: canvas.width / 2, y: canvas.height / 2 }]
      });
    }
  }
  
  // Enhanced Particle class with more visual appeal
  class Particle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.size = Math.random() * 5 + 2; // Larger particles
      this.speedX = (Math.random() * 2 - 1) * 3; // Faster movement
      this.speedY = (Math.random() * 2 - 1) * 3;
      // Colors as requested
      const colors = ['#FFE600', '#FFFFFF', '#808080'];
      this.color = colors[Math.floor(Math.random() * colors.length)];
      this.life = 60; // Longer life
      this.opacity = 1;
      this.initialSize = this.size;
    }
    
    update() {
      this.x += this.speedX;
      this.y += this.speedY;
      this.speedX *= 0.98; // Gradual slowdown
      this.speedY *= 0.98;
      this.life--;
      this.opacity = this.life / 60; // Fade out
      this.size = this.initialSize * (this.life / 60); // Shrink
    }
    
    draw() {
      ctx.globalAlpha = this.opacity;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Add glow effect
      ctx.shadowBlur = 10;
      ctx.shadowColor = this.color;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }
  
  // Show tooltip with Lean Six Sigma terminology
  function showTooltip(message, duration = 3000) {
    tooltip.textContent = message;
    tooltip.style.display = 'block';
    
    setTimeout(() => {
      tooltip.style.opacity = 0;
      setTimeout(() => {
        tooltip.style.display = 'none';
        tooltip.style.opacity = 1;
      }, 1000);
    }, duration);
  }
  
  // Add these variables for threshold tracking
  let processLoadThresholds = {
    threshold1: { value: PROCESS_LOAD_GOAL * 0.25, triggered: false },
    threshold2: { value: PROCESS_LOAD_GOAL * 0.5, triggered: false },
    threshold3: { value: PROCESS_LOAD_GOAL * 0.75, triggered: false }
  };
  
  // Function to show a message about the game freeze
  function showFreezeMessage() {
    // Clear any existing message timeout
    if (messageTimeout) {
      clearTimeout(messageTimeout);
    }
    
    // Display a persistent message about the freeze
    const freezeMsg = "Process load critical threshold reached (300 collisions). System paused to prevent browser overload.";
    businessMessage.textContent = freezeMsg;
    businessMessage.style.opacity = 1;
    
    // Style the message to make it more noticeable
    businessMessage.style.backgroundColor = 'rgba(220, 20, 20, 0.8)'; // Reddish background
    businessMessage.style.color = 'white';
    businessMessage.style.padding = '10px 15px';
    businessMessage.style.fontWeight = 'bold';
    businessMessage.style.borderLeft = '3px solid #FFFFFF';
    
    // Don't set a timeout - message stays until user takes action
    
    // Also show a tooltip that will fade away
    showTooltip("System frozen: Press 'Reset Simulation' to reset and continue.", 8000);
  }
  
  // Function to create a visual freeze effect
  function createFreezeEffect() {
    // Create a frost/freeze overlay effect
    const freezeOverlay = document.createElement('div');
    freezeOverlay.id = 'freezeOverlay';
    freezeOverlay.style.position = 'absolute';
    freezeOverlay.style.top = '0';
    freezeOverlay.style.left = '0';
    freezeOverlay.style.width = '100%';
    freezeOverlay.style.height = '100%';
    freezeOverlay.style.backgroundColor = 'rgba(100, 149, 237, 0.2)'; // Light blue tint
    freezeOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through
    freezeOverlay.style.zIndex = '10';
    
    // Add a subtle frost-like pattern
    freezeOverlay.style.backgroundImage = 'radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px)';
    freezeOverlay.style.backgroundSize = '10px 10px';
    
    // Add to the maze container
    mazeContainer.appendChild(freezeOverlay);
  }
  
  // Function to freeze the game
  function freezeGame() {
    isGameFrozen = true;
    
    // Display a notification about the freeze
    showFreezeMessage();
    
    // Create a visual freeze effect
    createFreezeEffect();
  }
  
  // Modified showBusinessMessage for smart message selection
  function showBusinessMessage(category, value, oldValue, specificMessage = null) {
    // Clear any existing message timeout
    if (messageTimeout) {
      clearTimeout(messageTimeout);
    }
    
    // Use the specific message if provided
    let message = specificMessage;
    
    // If no specific message, generate one based on category and values
    if (!message) {
      if (value !== undefined && category in businessMessages) {
        message = getSmartBusinessMessage(category, value, oldValue);
      } else if (category in businessMessages) {
        // If no value provided, get a message based on current slider value
        const slider = getSliderByCategory(category);
        if (slider) {
          const currentValue = parseFloat(slider.value);
          message = getSmartBusinessMessage(category, currentValue);
        } else if (category === 'process') {
          // Process messages have separate structure
          message = businessMessages.process.threshold1;
        } else {
          // Fallback to a message from the category
          const messageTypes = Object.keys(businessMessages[category]);
          const randomType = messageTypes[Math.floor(Math.random() * messageTypes.length)];
          message = businessMessages[category][randomType];
        }
      } else {
        message = "Process status updated.";
      }
    }
    
    // Display the message
    businessMessage.textContent = message;
    businessMessage.style.opacity = 1;
    
    // Set timeout to fade out after 3 seconds (unless this is a freeze message)
    if (!isGameFrozen) {
      messageTimeout = setTimeout(() => {
        businessMessage.style.opacity = 0;
      }, 3000);
    }
  }
  
  /**
   * Updates the process KPIs based on game state
   */
  function updateProcessKPIs() {
    // Only update if the game is not frozen
    if (isGameFrozen) return;
    
    // Current time for calculations
    const currentTime = performance.now();
    
    // Process Cycle Time calculation (in simulated days)
	const elapsedMilliseconds = currentTime - startTime;
	const processCycleTime = (elapsedMilliseconds / 1000 / 10).toFixed(1); // 1 second = 0.1 simulated days
	leadTimeValue.textContent = processCycleTime + " days";

	// Time Savings Percentage (formerly Value Added)
	// Estimate time savings based on movement without collisions
	totalProcessTime += 16.67; // approx ms per frame
	if (collisionCount === 0 || collisionCount === lastCollisionCount) {
	  valueAddedTime += 16.67;
	}
	const timeSavingsPercent = Math.round((valueAddedTime / totalProcessTime) * 100);
	valueAddedValue.textContent = timeSavingsPercent + "%";

	// Automation Complexity based on exceptions
	// Scale from 1-5 where 1 is simple and 5 is complex
	let automationComplexity;
	if (collisionCount === 0) {
	  automationComplexity = 1.0; // Simple automation
	} else {
	  // Basic formula to convert exception count to complexity level (simplified)
	  automationComplexity = Math.min(5, 1 + (collisionCount / 20));
	}
	sigmaLevelValue.textContent = automationComplexity.toFixed(1);

	// Process Success Rate (formerly First Pass Yield)
	// Decreases with each exception, but can't go below 0
	firstPassYield = Math.max(0, 100 - (collisionCount * 2));
	fttValue.textContent = firstPassYield.toFixed(0) + "%";
    
    // Track last collision count for value-added calculation
    lastCollisionCount = collisionCount;
    
    // Update objectives based on KPIs
	
	
    updateObjectives();
	
	// HIGHLIGHT VALUES THAT CHANGED
  const highlightIfChanged = (element, prevValue, newValue) => {
    if (prevValue !== newValue) {
      element.style.color = '#FFD700'; // Highlight to gold
      setTimeout(() => {
        element.style.color = ''; // Reset to default (white)
      }, 500);
    }
  };
  
  const prevCycleTime = leadTimeValue.textContent;
const prevTimeSavings = valueAddedValue.textContent;
const prevComplexity = sigmaLevelValue.textContent;
const prevSuccess = fttValue.textContent;

  highlightIfChanged(leadTimeValue, prevCycleTime, leadTimeValue.textContent);
  highlightIfChanged(valueAddedValue, prevTimeSavings, valueAddedValue.textContent);
  highlightIfChanged(sigmaLevelValue, prevComplexity, sigmaLevelValue.textContent);
  highlightIfChanged(fttValue, prevSuccess, fttValue.textContent);
	
	
  }
  
  /**
   * Updates the status of improvement objectives
   * @param {number} timeSavingsPercent - Current value-added percentage
   * @param {number} firstPassYield - Current first pass yield
   * @param {number} leadTimeDays - Current lead time in days
   */
function updateObjectives() {
  // Calculate normalized values (0-100%) for all relevant sliders
  const documentationLevel = (parseInt(containerSizeSlider.value) - 450) / (800 - 450) * 100;
  const standardizationLevel = (parseFloat(headSizeSlider.value) - 3) / (20 - 3) * 100;
  const knowledgeBaseLevel = (parseInt(trailLengthSlider.value) - 1000) / (8000 - 1000) * 100;
  const processVariability = 100 - ((parseInt(obstacleSizeSlider.value) - 20) / (80 - 20) * 100);
  const manualInterventionRate = 100 - ((parseFloat(obstaclesPerWaveSlider.value) - 0.5) / (2.0 - 0.5) * 100);
  const exceptionHandlingQuality = (parseFloat(obstacleSpeedSlider.value) - 0.5) / (3.0 - 0.5) * 100;
  
  // Objective 1: Achieve 95% process documentation coverage
  // This is influenced by documentation level and knowledge base coverage
  const documentationScore = (documentationLevel * 0.6) + (knowledgeBaseLevel * 0.4);
  const objective1Status = document.getElementById('objective1Status');
  if (documentationScore >= 95) {
    objective1Status.classList.remove('incomplete');
    objective1Status.classList.add('complete');
  } else {
    objective1Status.classList.remove('complete');
    objective1Status.classList.add('incomplete');
  }
  
  // Objective 2: Reach 85% standardization level
  // This is influenced by standardization level and process variability
  const standardizationScore = (standardizationLevel * 0.7) + (processVariability * 0.3);
  const objective2Status = document.getElementById('objective2Status');
  if (standardizationScore >= 85) {
    objective2Status.classList.remove('incomplete');
    objective2Status.classList.add('complete');
  } else {
    objective2Status.classList.remove('complete');
    objective2Status.classList.add('incomplete');
  }
  
  // Objective 3: Reduce manual workload by 40%
  // This is influenced by manual intervention rate and exception handling quality
  const workloadReductionScore = (manualInterventionRate * 0.6) + (exceptionHandlingQuality * 0.4);
  const objective3Status = document.getElementById('objective3Status');
  if (workloadReductionScore >= 40) {
    objective3Status.classList.remove('incomplete');
    objective3Status.classList.add('complete');
  } else {
    objective3Status.classList.remove('complete');
    objective3Status.classList.add('incomplete');
  }
}
  
  // Update process load with Six Sigma thresholds
  function updateProcessLoad(load) {
    // Limit the load to the equivalent of 300 collisions (15000)
    const cappedLoad = Math.min(load, 15000);
    
    // Update the progress bar
    const percent = Math.min((cappedLoad / PROCESS_LOAD_GOAL) * 100, 100);
    complexityProgress.style.width = percent + '%';
    complexityValueDisplay.textContent = Math.floor(cappedLoad);
    
    // Track color changes using data attributes instead of checking the style directly
    if (cappedLoad >= 1700 && complexityProgress.getAttribute('data-color-level') !== '3') {
      complexityProgress.style.backgroundColor = '#FF6B35'; // Orange-red
      complexityProgress.setAttribute('data-color-level', '3');
      showBusinessMessage("process", null, null, businessMessages.process.threshold3);
    } else if (cappedLoad >= 1200 && cappedLoad < 1700 && complexityProgress.getAttribute('data-color-level') !== '2') {
      complexityProgress.style.backgroundColor = '#FF8C00'; // Dark orange
      complexityProgress.setAttribute('data-color-level', '2');
      showBusinessMessage("process", null, null, businessMessages.process.threshold2);
    } else if (cappedLoad >= 500 && cappedLoad < 1200 && complexityProgress.getAttribute('data-color-level') !== '1') {
      complexityProgress.style.backgroundColor = '#FFA500'; // Orange
      complexityProgress.setAttribute('data-color-level', '1');
      showBusinessMessage("process", null, null, businessMessages.process.threshold1);
    } else if (cappedLoad < 500 && complexityProgress.getAttribute('data-color-level') !== '0') {
      // Reset to default color if below threshold
      complexityProgress.style.backgroundColor = '#FFD700'; // Default gold color
      complexityProgress.removeAttribute('data-color-level');
    }
    
    // Check for game completion
    if (cappedLoad >= PROCESS_LOAD_GOAL && !processLoadGoalReached) {
      processLoadGoalReached = true;
      overlayMessage.style.display = 'flex';
    }
  }
  
  // Create enhanced particles effect
  function createParticles(x, y) {
    for (let i = 0; i < 40; i++) { // More particles
      particles.push(new Particle(x, y));
    }
    isEffectActive = true;
  }
  
  // Change head direction
  function changeDirection(headIndex) {
    const head = heads[headIndex];
    const randomAngle = Math.random() * Math.PI * 2;
    head.dirX = Math.cos(randomAngle) * SPEED;
    head.dirY = Math.sin(randomAngle) * SPEED;
  }
  
  // Update wave countdown with DMAIC phase indication
  function updateWaveCountdown(deltaTime) {
    // Skip if game is frozen
    if (isGameFrozen) return;
    
    waveCountdown -= deltaTime;
    // Set the new countdown max each time the frequency changes
    waveCountdownMax = 15000 / waveFrequencyFactor;
    const percent = Math.max((waveCountdown / waveCountdownMax) * 100, 0);
    waveCountdownProgress.style.width = percent + '%';
    
    // Determine DMAIC phase based on countdown progress
    const phasePercent = (waveCountdownMax - waveCountdown) / waveCountdownMax;
    let phaseMessage = "";
    
	if (phasePercent < 0.2) {
	  waveCountdownProgress.style.backgroundColor = "#3498db";
	  phaseMessage = "Planning: Identifying automation opportunities";
	} else if (phasePercent < 0.4) {
	  waveCountdownProgress.style.backgroundColor = "#2ecc71";
	  phaseMessage = "Design: Creating automation solution blueprint";
	} else if (phasePercent < 0.6) {
	  waveCountdownProgress.style.backgroundColor = "#f1c40f";
	  phaseMessage = "Development: Building automation workflows";
	} else if (phasePercent < 0.8) {
	  waveCountdownProgress.style.backgroundColor = "#e67e22";
	  phaseMessage = "Testing: Validating automation solution";
	} else {
	  waveCountdownProgress.style.backgroundColor = "#9b59b6";
	  phaseMessage = "Deployment: Implementing automation in production";
	}
    
    
    // Update tooltip with DMAIC phase information when hovering over the wave progress bar
    const waveProgressElement = document.getElementById('waveCountdownProgress');
    waveProgressElement.setAttribute('title', phaseMessage);
    
    if (waveCountdown <= 0) {
      triggerWave();
      waveCountdown = waveCountdownMax; // Reset countdown with new max value
    }
  }
  
  // Trigger a new wave of obstacles
  function triggerWave() {
    // Always create at least a few obstacles, even on first wave
    const baseObstacles = Math.floor(5 * obstaclesRatio);
    const additionalObstacles = collisionCount < 4 ? 0 : Math.floor(collisionCount / 20);
    const numObstacles = baseObstacles + additionalObstacles;
    
    for (let i = 0; i < numObstacles; i++) {
      const size = customObstacleSize;
      const obstacle = {
        x: Math.random() * (canvas.width - size),
        y: Math.random() * (canvas.height - size),
        width: size,
        height: size,
        vx: (Math.random() * 2 - 1) * customObstacleSpeed,
        vy: (Math.random() * 2 - 1) * customObstacleSpeed
      };
      obstacles.push(obstacle);
    }
    showTooltip("New automation release cycle initiated - updating process documentation!");
  }
  
  // Update obstacles
  function updateObstacles() {
    obstacles.forEach(obs => {
      obs.x += obs.vx;
      obs.y += obs.vy;
      
      // Bounce off walls
      if (obs.x < 0 || obs.x + obs.width > canvas.width) {
        obs.vx = -obs.vx;
        obs.x = Math.max(0, Math.min(canvas.width - obs.width, obs.x));
      }
      if (obs.y < 0 || obs.y + obs.height > canvas.height) {
        obs.vy = -obs.vy;
        obs.y = Math.max(0, Math.min(canvas.height - obs.height, obs.y));
      }
    });
  }
  
  // Check head collisions
  function checkHeadCollisions() {
    for (let i = 0; i < heads.length - 1; i++) {
      for (let j = i + 1; j < heads.length; j++) {
        const dx = heads[i].x - heads[j].x;
        const dy = heads[i].y - heads[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < DOT_RADIUS * 2) {
          // Collision detected, change direction of both heads
          changeDirection(i);
          changeDirection(j);
          headCollisionCount++; // Count head collisions
          collisionCount++; // Add to main collision count for process load
          createParticles((heads[i].x + heads[j].x) / 2, (heads[i].y + heads[j].y) / 2);
          showTooltip("Resource constraint detected - implementing workflow optimization!");
          
          // Check if reached 300 collisions
          if (collisionCount >= 300 && !isGameFrozen) {
            freezeGame();
          }
        }
      }
    }
  }
  
// Draw game state
function draw() {
  // Clear the canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw static trails with gradient effect
  staticTrails.forEach(trail => {
    if (trail.length < 2) return;
    
    for (let i = 1; i < trail.length; i++) {
      // Calculate opacity based on position in trail - brighter at the end
      const opacity = i / trail.length;
      
      ctx.beginPath();
      ctx.moveTo(trail[i-1].x, trail[i-1].y);
      ctx.lineTo(trail[i].x, trail[i].y);
      ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.lineWidth = LINE_WIDTH;
      ctx.stroke();
    }
  });
  
  // Draw head trails with gradient effect - white at head, darker at the end
  heads.forEach(head => {
    if (head.trail.length < 2) return;
    
    for (let i = 1; i < head.trail.length; i++) {
      // Calculate opacity based on position in trail - brighter near head
      const opacity = (i / head.trail.length);
      
      ctx.beginPath();
      ctx.moveTo(head.trail[i-1].x, head.trail[i-1].y);
      ctx.lineTo(head.trail[i].x, head.trail[i].y);
      ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.lineWidth = LINE_WIDTH;
      ctx.stroke();
    }
  });
  
  // Draw obstacles as different types of business challenges
  obstacles.forEach((obstacle, index) => {
    ctx.save();
    
    // First calculate the center coordinates
    const centerX = obstacle.x + obstacle.width / 2;
    const centerY = obstacle.y + obstacle.height / 2;
    
    // Add subtle animation
    const time = performance.now() / 1000;
    const wobble = Math.sin(time * 2 + index) * 2; // Small wobble effect
    
    ctx.translate(centerX, centerY);
    
    // Subtle rotation for some obstacle types
    if (index % 4 === 2) { // Only rotate certain obstacles
      const rotateAmount = Math.sin(time * 0.5 + index) * 0.1;
      ctx.rotate(rotateAmount);
    }
    
    // Assign obstacle type based on index (evenly distribute types)
    const obstacleType = index % 4;
    
    switch(obstacleType) {
      case 0: // Quality issues (red diamonds)
        ctx.rotate(Math.PI / 4);
        ctx.fillStyle = "#FF5555";
        ctx.shadowColor = "#FF5555";
        ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
        break;
        
      case 1: // Resource constraints (orange squares)
        ctx.fillStyle = "#FF8C00";
        ctx.shadowColor = "#FF8C00";
        ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
        break;
        
      case 2: // Compliance risks (purple hexagons)
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i;
          const x = Math.cos(angle) * (obstacle.width / 2);
          const y = Math.sin(angle) * (obstacle.height / 2);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fillStyle = "#9370DB";
        ctx.shadowColor = "#9370DB";
        ctx.fill();
        break;
        
      case 3: // Technical debt (gray circles)
        ctx.beginPath();
        ctx.arc(0, 0, obstacle.width / 2, 0, Math.PI * 2);
        ctx.fillStyle = "#A9A9A9";
        ctx.shadowColor = "#A9A9A9";
        ctx.fill();
        break;
    }
    
    ctx.shadowBlur = 15;
    ctx.restore();
  });
  
  // Draw particles
  if (isEffectActive) {
    particles.forEach(particle => particle.draw());
  }
  
  // Draw heads
  heads.forEach(head => {
    ctx.beginPath();
    ctx.arc(head.x, head.y, DOT_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = '#ecd404';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ecd404';
    ctx.fill();
    ctx.shadowBlur = 0;
  });
}
  
  // Game loop
  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }
  
function fixLayoutAfterResize() {
  // Fix for right-hand slider visibility issue
  const gameControlWrapper = document.querySelector('.game-control-wrapper');
  const mazeWidth = mazeContainer.clientWidth;
  const windowWidth = window.innerWidth;
  const containerWidth = document.querySelector('.container').clientWidth;
  
  // Check if maze size is pushing content outside the viewport
  const isOverflowing = (mazeWidth > windowWidth * 0.6);
  
  // Apply responsive layout
  setTimeout(() => {
    // Auto-switch to a mobile-friendly layout when needed
    if (windowWidth <= 768 || isOverflowing) {
      // Stack layout (controls below maze)
      gameControlWrapper.style.gridTemplateColumns = "1fr";
      gameControlWrapper.style.gridTemplateAreas = 
        '"maze" "controls" "process"';
      
      // Center the maze
      mazeContainer.style.margin = "0 auto";
      mazeContainer.style.maxWidth = Math.min(containerWidth, windowWidth - 40) + "px";
    } else {
      // Desktop side-by-side layout
      gameControlWrapper.style.gridTemplateColumns = "auto 1fr";
      gameControlWrapper.style.gridTemplateAreas = 
        '"maze controls" "process process"';
    }
    
    // Ensure the maze doesn't exceed container boundaries
    if (parseInt(containerSizeSlider.value) > containerWidth * 0.7) {
      const maxSize = Math.min(containerWidth * 0.7, windowWidth - 40);
      mazeContainer.style.width = maxSize + "px";
      mazeContainer.style.height = maxSize + "px";
      
      // Update canvas size to match constrained container
      canvas.width = mazeContainer.clientWidth;
      canvas.height = mazeContainer.clientHeight;
    }
    
    // Force browser to recalculate layout
    gameControlWrapper.offsetHeight;
    
    // Always make sure controls are visible
    const controlsContainer = document.querySelector('.controls-container');
    if (controlsVisible) {
      controlsContainer.style.display = 'grid';
    }
  }, 50);
}
  
 // Update game state
// Replace your entire update function with this version
function update() {
  // Skip updating if the game is frozen or currently resizing
  if (isGameFrozen || isResizing) {
    return;
  }
  
  // CRITICAL: Double-check canvas dimensions match container
  if (canvas.width !== mazeContainer.clientWidth || canvas.height !== mazeContainer.clientHeight) {
    canvas.width = mazeContainer.clientWidth;
    canvas.height = mazeContainer.clientHeight;
  }
  
  // Update obstacles first
  updateObstacles();
  
  // Update heads with bulletproof bounds checking
  heads.forEach((head, i) => {
    // Store previous position
    const prevX = head.x;
    const prevY = head.y;
    
    // Calculate new position but don't apply yet
    const newX = head.x + head.dirX;
    const newY = head.y + head.dirY;
    
    // Check bounds using current canvas dimensions
    let boundaryCollision = false;
    
    // X-axis boundary checks
    if (newX - DOT_RADIUS <= 0) {
      // Would hit left wall
      head.x = DOT_RADIUS + 1; // Push inside boundary
      head.dirX = Math.abs(head.dirX); // Force positive X direction
      boundaryCollision = true;
      wallCollisionCount++;
    } else if (newX + DOT_RADIUS >= canvas.width) {
      // Would hit right wall
      head.x = canvas.width - DOT_RADIUS - 1; // Push inside boundary
      head.dirX = -Math.abs(head.dirX); // Force negative X direction
      boundaryCollision = true;
      wallCollisionCount++;
    } else {
      // Safe to move in X direction
      head.x = newX;
    }
    
    // Y-axis boundary checks
    if (newY - DOT_RADIUS <= 0) {
      // Would hit top wall
      head.y = DOT_RADIUS + 1; // Push inside boundary
      head.dirY = Math.abs(head.dirY); // Force positive Y direction
      boundaryCollision = true;
      wallCollisionCount++;
    } else if (newY + DOT_RADIUS >= canvas.height) {
      // Would hit bottom wall
      head.y = canvas.height - DOT_RADIUS - 1; // Push inside boundary
      head.dirY = -Math.abs(head.dirY); // Force negative Y direction
      boundaryCollision = true;
      wallCollisionCount++;
    } else {
      // Safe to move in Y direction
      head.y = newY;
    }
    
    // Emergency safety check
    if (isNaN(head.x) || isNaN(head.y) || 
        head.x < 0 || head.x > canvas.width || 
        head.y < 0 || head.y > canvas.height) {
      // Reset to center if position is invalid
      head.x = canvas.width / 2;
      head.y = canvas.height / 2;
      head.trail = [{ x: head.x, y: head.y }];
      
      // Give it a new random direction
      const randomAngle = Math.random() * Math.PI * 2;
      head.dirX = Math.cos(randomAngle) * SPEED;
      head.dirY = Math.sin(randomAngle) * SPEED;
    }
    
    // Only check for obstacle collisions if we haven't already hit a boundary
    if (!boundaryCollision) {
      obstacles.forEach((obstacle, obsIndex) => {
        if (head.x + DOT_RADIUS > obstacle.x && 
            head.x - DOT_RADIUS < obstacle.x + obstacle.width &&
            head.y + DOT_RADIUS > obstacle.y && 
            head.y - DOT_RADIUS < obstacle.y + obstacle.height) {
          
          // Create a unique collision ID
          const collisionId = `${i}-${obsIndex}`;
          
          // Only count the collision if it hasn't been recorded yet
          if (!headObstacleCollisions.has(collisionId)) {
            headObstacleCollisions.add(collisionId);
            
            // Collision detected - calculate bounce angle
            const obsCenterX = obstacle.x + obstacle.width/2;
            const obsCenterY = obstacle.y + obstacle.height/2;
            const angle = Math.atan2(
              head.y - obsCenterY, 
              head.x - obsCenterX
            );
            
            // Set new direction with a slight randomization for more natural movement
            const randomFactor = 0.2; // Small random factor
            head.dirX = (Math.cos(angle) + (Math.random() * randomFactor - randomFactor/2)) * SPEED;
            head.dirY = (Math.sin(angle) + (Math.random() * randomFactor - randomFactor/2)) * SPEED;
            
            // Count collision
            collisionCount++; 
            
            // Create particles
            createParticles(head.x, head.y);
            
            // Check if we've reached collision limit
            if (collisionCount >= 300 && !isGameFrozen) {
              freezeGame();
            }
          }
        } else {
          // Clear collision record if no longer colliding
          headObstacleCollisions.delete(`${i}-${obsIndex}`);
        }
      });
    }
    
    // Update trail (after position is finalized and boundaries enforced)
    head.trail.push({x: head.x, y: head.y});
    if (head.trail.length > MAX_TRAIL_LENGTH) {
      head.trail.shift();
    }
  });
  
  // Check head collisions
  checkHeadCollisions();
  
  // Update particles
  if (isEffectActive) {
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      if (particles[i].life <= 0) {
        particles.splice(i, 1);
      }
    }
    if (particles.length === 0) {
      isEffectActive = false;
    }
  }
  
  // Update process load
  const processLoad = collisionCount * 50;
  updateProcessLoad(processLoad);
  
  // Update collisions display
  collisionsValue.textContent = collisionCount;
  
  // Update KPIs
  updateProcessKPIs();
  
  // Update wave countdown
  const now = performance.now();
  const deltaTime = now - lastFrameTime;
  lastFrameTime = now;
  updateWaveCountdown(deltaTime);
}
  
// Replace both of your existing containerSizeSlider event listeners
containerSizeSlider.addEventListener('input', function() {
  const size = parseInt(this.value);
  const businessValue = getBusinessValue('containerSize', size);
  containerSizeValue.textContent = businessValue;
  
  // Store previous value for smart message
  const previousValue = this.getAttribute('data-prev-value') || this.value;
  
  // Show business message
  showBusinessMessage('containerSize', size, previousValue);
  
  // Update stored value
  this.setAttribute('data-prev-value', size);
});

containerSizeSlider.addEventListener('change', function() {
  isResizing = true;
  
  const sliderValue = parseInt(this.value);
  const windowWidth = window.innerWidth;
  const containerWidth = document.querySelector('.container').clientWidth;
  
  // Calculate the raw value that corresponds to 80 on the slider scale
  const rawValueFor80 = 450 + ((80 - 20) / (100 - 20)) * (800 - 450); // approx 670
  
  // Set the threshold one tick lower than 80
  // Assuming each step is about 5-10 units on the raw scale
  const threshold = rawValueFor80 - 10; // One tick earlier than 80
  
  // Remove any existing layout fix first
  const existingFix = document.getElementById('layout-fix');
  if (existingFix) existingFix.remove();
  
  // Check if we're at or exceeding the threshold (slightly before value 80)
  const isAtThresholdOrAbove = sliderValue >= threshold;
  
  // At or above threshold, we need to ensure all sliders are visible
  if (isAtThresholdOrAbove) {
    // Use vertical layout with sliders below game
    document.head.insertAdjacentHTML('beforeend', `
      <style id="layout-fix">
        /* Main layout grid */
        .game-control-wrapper {
          display: grid !important;
          grid-template-columns: 1fr !important;
          grid-template-areas: "maze" "controls" "process" !important;
          gap: 20px !important;
        }
        
        /* Center maze */
        #mazeContainer {
          margin: 0 auto !important;
          width: ${sliderValue}px !important;
          height: ${sliderValue}px !important;
        }
        
        /* Make controls container display properly */
        .controls-container {
          display: grid !important;
          grid-template-columns: 1fr 1fr !important;
          gap: 20px !important;
        }
        
        /* Force both control panels to be completely visible */
        .standard-controls, .advanced-controls {
          width: 100% !important;
          max-width: 100% !important;
          min-width: 0 !important;
        }
        
        /* Force controls wrapper to take full width */
        .controls-wrapper {
          width: 100% !important;
        }
      </style>
    `);
  } else {
    // For values below the threshold, use normal side-by-side layout
    document.head.insertAdjacentHTML('beforeend', `
      <style id="layout-fix">
        @media (min-width: 769px) {
          .game-control-wrapper {
            display: grid !important;
            grid-template-columns: auto 1fr !important;
            grid-template-areas: "maze controls" "process process" !important;
            gap: 20px !important;
          }
          
          .controls-container {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 20px !important;
          }
          
          #mazeContainer {
            width: ${sliderValue}px !important;
            height: ${sliderValue}px !important;
          }
        }
      </style>
    `);
  }
  
  // Force layout update
  document.body.offsetHeight;
  
  // Always ensure controls are visible if they should be
  const controlsContainer = document.querySelector('.controls-container');
  if (controlsVisible) {
    controlsContainer.style.display = 'grid';
    
    // Fix for controls container layout
    if (isAtThresholdOrAbove) {
      // Ensure controls container has the right display properties
      controlsContainer.style.cssText = `
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        gap: 20px !important;
      `;
    }
  } else {
    controlsContainer.style.display = 'none';
  }
  
  // Update canvas immediately
  requestAnimationFrame(() => {
    canvas.width = mazeContainer.clientWidth;
    canvas.height = mazeContainer.clientHeight;
    
    // Complete the resize operation
    heads.forEach(head => {
      const buffer = 2;
      head.x = Math.max(DOT_RADIUS + buffer, Math.min(head.x, canvas.width - DOT_RADIUS - buffer));
      head.y = Math.max(DOT_RADIUS + buffer, Math.min(head.y, canvas.height - DOT_RADIUS - buffer));
      head.trail = [{ x: head.x, y: head.y }];
    });
    
    obstacles.forEach(obs => {
      obs.x = Math.max(0, Math.min(obs.x, canvas.width - obs.width));
      obs.y = Math.max(0, Math.min(obs.y, canvas.height - obs.height));
    });
    
    draw();
    isResizing = false;
  });
});

  
  // Head size slider
  headSizeSlider.addEventListener('input', function() {
    DOT_RADIUS = parseFloat(this.value);
    const businessValue = getBusinessValue('headSize', DOT_RADIUS);
    headSizeValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Show business message
    showBusinessMessage('headSize', DOT_RADIUS, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', DOT_RADIUS);
  });
  
  // Trail Length slider
  trailLengthSlider.addEventListener('input', function() {
    MAX_TRAIL_LENGTH = parseInt(this.value);
    const businessValue = getBusinessValue('trailLength', MAX_TRAIL_LENGTH);
    trailLengthValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Trim existing trails if needed
    heads.forEach(head => {
      if (head.trail.length > MAX_TRAIL_LENGTH) {
        head.trail = head.trail.slice(head.trail.length - MAX_TRAIL_LENGTH);
      }
    });
    
    staticTrails.forEach((trail, index) => {
      if (trail.length > MAX_TRAIL_LENGTH) {
        staticTrails[index] = trail.slice(trail.length - MAX_TRAIL_LENGTH);
      }
    });
    
    // Show business message
    showBusinessMessage('trailLength', MAX_TRAIL_LENGTH, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', MAX_TRAIL_LENGTH);
  });
  
  // Speed slider
  speedSlider.addEventListener('input', function() {
    SPEED = parseFloat(this.value);
    const businessValue = getBusinessValue('speed', SPEED);
    speedValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Update head speeds
    heads.forEach(head => {
      const angle = Math.atan2(head.dirY, head.dirX);
      head.dirX = Math.cos(angle) * SPEED;
      head.dirY = Math.sin(angle) * SPEED;
    });
    
    // Show business message
    showBusinessMessage('speed', SPEED, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', SPEED);
  });
  
  // Number of heads slider
  numHeadsSlider.addEventListener('input', function() {
    const newNumHeads = parseInt(this.value);
    const businessValue = getBusinessValue('numHeads', newNumHeads);
    numHeadsValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Add or remove heads as needed
    while (heads.length < newNumHeads) {
      heads.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        dirX: (Math.random() * 2 - 1) * SPEED,
        dirY: (Math.random() * 2 - 1) * SPEED,
        trail: [{ x: canvas.width / 2, y: canvas.height / 2 }]
      });
    }
    
    while (heads.length > newNumHeads) {
      const removed = heads.pop();
      staticTrails.push(removed.trail);
    }
    
    // Show business message
    showBusinessMessage('numHeads', newNumHeads, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', newNumHeads);
  });
  
  // Wave frequency slider
  waveFrequencySlider.addEventListener('input', function() {
    waveFrequencyFactor = parseFloat(this.value);
    const businessValue = getBusinessValue('waveFrequency', waveFrequencyFactor);
    waveFrequencyValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Update the waveCountdownMax
    waveCountdownMax = 15000 / waveFrequencyFactor;
    // Reset the current countdown to match the new max (maintain the same percentage)
    const currentPercent = waveCountdown / (15000 / (waveFrequencyFactor - (this.value - (this.oldValue || this.value))));
    waveCountdown = currentPercent * waveCountdownMax;
    
    // Show business message
    showBusinessMessage('waveFrequency', waveFrequencyFactor, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', waveFrequencyFactor);
  });
  
  // Add an event listener to track the old value
  waveFrequencySlider.addEventListener('mousedown', function() {
    this.oldValue = parseFloat(this.value);
  });
  
  waveFrequencySlider.addEventListener('touchstart', function() {
    this.oldValue = parseFloat(this.value);
  });
  
  // Obstacle size slider
  obstacleSizeSlider.addEventListener('input', function() {
    customObstacleSize = parseInt(this.value);
    const businessValue = getBusinessValue('obstacleSize', customObstacleSize);
    obstacleSizeValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Update existing obstacles
    obstacles.forEach(obs => {
      obs.width = customObstacleSize;
      obs.height = customObstacleSize;
    });
    
    // Show business message
    showBusinessMessage('obstacleSize', customObstacleSize, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', customObstacleSize);
  });
  
  // Obstacle speed slider
  obstacleSpeedSlider.addEventListener('input', function() {
    customObstacleSpeed = parseFloat(this.value);
    const businessValue = getBusinessValue('obstacleSpeed', customObstacleSpeed);
    obstacleSpeedValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Update existing obstacles
    obstacles.forEach(obs => {
      obs.vx = Math.sign(obs.vx) * customObstacleSpeed;
      obs.vy = Math.sign(obs.vy) * customObstacleSpeed;
    });
    
    // Show business message
    showBusinessMessage('obstacleSpeed', customObstacleSpeed, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', customObstacleSpeed);
  });
  
  // Obstacles per wave ratio slider
  obstaclesPerWaveSlider.addEventListener('input', function() {
    obstaclesRatio = parseFloat(this.value);
    const businessValue = getBusinessValue('obstaclesPerWave', obstaclesRatio);
    obstaclesPerWaveValue.textContent = businessValue;
    
    // Store previous value for smart message
    const previousValue = this.getAttribute('data-prev-value') || this.value;
    
    // Show business message
    showBusinessMessage('obstaclesPerWave', obstaclesRatio, previousValue);
    
    // Update stored value
    this.setAttribute('data-prev-value', obstaclesRatio);
  });
  
  // Clear button
  clearButton.addEventListener('click', function() {
    heads.forEach(head => {
      head.trail = [{ x: head.x, y: head.y }];
    });
    staticTrails = [];
    obstacles = [];
    collisionCount = 0;
    headCollisionCount = 0;
    wallCollisionCount = 0;
    headObstacleCollisions.clear(); // Clear the collision tracking
    waveCountdown = waveCountdownMax;
    updateProcessLoad(0);
    processLoadGoalReached = false;
    overlayMessage.style.display = 'none';
    
    // Reset KPI tracking variables
    startTime = performance.now();
    valueAddedTime = 0;
    totalProcessTime = 0;
    firstPassYield = 100;
    lastCollisionCount = 0;
    
    // Reset threshold triggers
    processLoadThresholds.threshold1.triggered = false;
    processLoadThresholds.threshold2.triggered = false;
    processLoadThresholds.threshold3.triggered = false;
    
    // Reset progress bar color
    complexityProgress.style.backgroundColor = '#FFD700';
    complexityProgress.removeAttribute('data-color-level');
    
    // Unfreeze the game if it was frozen
    if (isGameFrozen) {
      isGameFrozen = false;
      
      // Remove the freeze overlay if it exists
      const freezeOverlay = document.getElementById('freezeOverlay');
      if (freezeOverlay) {
        freezeOverlay.remove();
      }
      
      // Reset the business message styling
      businessMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
      businessMessage.style.color = '#FFD700';
      businessMessage.style.fontWeight = 'normal';
      businessMessage.style.borderLeft = 'none';
      businessMessage.style.padding = '5px 15px';
    }
    
    showBusinessMessage('containerSize', null, null, "Process reset complete. System ready for new operational cycle.");
  });
  
  // Restart button
  restartButton.addEventListener('click', function() {
    clearButton.click();
  });
  
  // Canvas click event - only create particles when clicking on heads or obstacles
// Canvas click event - only create particles when clicking on heads or obstacles
canvas.addEventListener('click', function(event) {
  // Skip if the game is frozen
  if (isGameFrozen) return;
  
  const rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;
  
  // Check if clicked on a head or near it (improved hit detection)
  for (let i = 0; i < heads.length; i++) {
    const head = heads[i];
    const distance = Math.sqrt(Math.pow(mouseX - head.x, 2) + Math.pow(mouseY - head.y, 2));
    // Increased detection radius for better usability
    if (distance <= DOT_RADIUS * 1.5) {
      changeDirection(i);
      createParticles(head.x, head.y);
      showTooltip("Workflow redirected - applying automation to maximize efficiency!");
      return;
    }
  }
  
  // Check if clicked on an obstacle - more lenient detection
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obs = obstacles[i];
    const centerX = obs.x + obs.width / 2;
    const centerY = obs.y + obs.height / 2;
    
    // More generous hit detection for obstacles (square-based)
    if (mouseX >= obs.x - 10 && mouseX <= obs.x + obs.width + 10 &&
        mouseY >= obs.y - 10 && mouseY <= obs.y + obs.height + 10) {
      // Create particles at the center of the obstacle
      createParticles(centerX, centerY);
      
      // Instead of removing the obstacle, shrink it
      const newWidth = Math.max(10, obs.width * 0.7);
      const newHeight = Math.max(10, obs.height * 0.7);
      
      // Keep obstacle centered while shrinking
      obs.x = centerX - (newWidth / 2);
      obs.y = centerY - (newHeight / 2);
      
      // Apply new dimensions
      obs.width = newWidth;
      obs.height = newHeight;
      
      // Only remove if it's been shrunk significantly
      if (newWidth <= 12) {
        obstacles.splice(i, 1);
      }
      
      showTooltip("Exception handled - process knowledge base updated!");
      return;
    }
  }
  
  // Removed particle creation on empty space clicks
});

// ADD THE TOUCH CONTROLS IMMEDIATELY AFTER THIS SECTION
// Touch controls for mobile
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;

canvas.addEventListener('touchstart', function(e) {
  // Only process if game is not frozen
  if (isGameFrozen) return;
  
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  touchStartTime = new Date().getTime();
  
  // Prevent scrolling only if touch is on a game element (head or obstacle)
  const rect = canvas.getBoundingClientRect();
  const touchX = touchStartX - rect.left;
  const touchY = touchStartY - rect.top;
  
  // Check if touch is on a head
  let onGameElement = false;
  
  // Check heads with a larger touch area for mobile
  for (let i = 0; i < heads.length; i++) {
    const head = heads[i];
    const distance = Math.sqrt(Math.pow(touchX - head.x, 2) + Math.pow(touchY - head.y, 2));
    if (distance <= DOT_RADIUS * 3) { // Extra large touch area
      onGameElement = true;
      break;
    }
  }
  
  // Check obstacles with a larger touch area
  if (!onGameElement) {
    for (let i = 0; i < obstacles.length; i++) {
      const obs = obstacles[i];
      // Larger hit area
      if (touchX >= obs.x - 30 && touchX <= obs.x + obs.width + 30 &&
          touchY >= obs.y - 30 && touchY <= obs.y + obs.height + 30) {
        onGameElement = true;
        break;
      }
    }
  }
  
  // Only prevent default if touching a game element
  if (onGameElement) {
    e.preventDefault();
  }
});

canvas.addEventListener('touchend', function(e) {
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  const touchEndTime = new Date().getTime();
  
  // Calculate swipe distance and time
  const diffX = touchEndX - touchStartX;
  const diffY = touchEndY - touchStartY;
  const diffTime = touchEndTime - touchStartTime;
  
  // Handle quick taps as regular clicks
  if (diffTime < 300 && Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
    // Use built-in click detection logic you already have
    const rect = canvas.getBoundingClientRect();
    const mouseX = touchEndX - rect.left;
    const mouseY = touchEndY - rect.top;
    
    // Check if clicked on a head
    for (let i = 0; i < heads.length; i++) {
      const head = heads[i];
      const distance = Math.sqrt(Math.pow(mouseX - head.x, 2) + Math.pow(mouseY - head.y, 2));
      if (distance <= DOT_RADIUS * 2) { // Larger tap area for mobile
        changeDirection(i);
        createParticles(head.x, head.y);
        showTooltip("Workflow redirected - applying automation to maximize efficiency!");
        return;
      }
    }
    
    // Check if clicked on an obstacle - more generous hit area
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs = obstacles[i];
      // Larger hit area for mobile
      if (mouseX >= obs.x - 20 && mouseX <= obs.x + obs.width + 20 &&
          mouseY >= obs.y - 20 && mouseY <= obs.y + obs.height + 20) {
        createParticles(obs.x + obs.width/2, obs.y + obs.height/2);
        obstacles.splice(i, 1);
        showTooltip("Exception handled - process knowledge base updated!");
        return;
      }
    }
    return;
  }
  
  // Only handle significant swipes
  if (Math.abs(diffX) > 30 || Math.abs(diffY) > 30) {
    // Find closest head to the touch point
    let closestHead = null;
    let closestDist = Infinity;
    let closestIndex = -1;
    
    heads.forEach((head, index) => {
      const rect = canvas.getBoundingClientRect();
      const touchX = touchStartX - rect.left;
      const touchY = touchStartY - rect.top;
      
      const dist = Math.sqrt(Math.pow(head.x - touchX, 2) + Math.pow(head.y - touchY, 2));
      if (dist < closestDist) {
        closestDist = dist;
        closestHead = head;
        closestIndex = index;
      }
    });
    
    // If we found a head within reasonable distance
    if (closestHead && closestDist < 150) {
      // Calculate direction based on swipe
      const angle = Math.atan2(diffY, diffX);
      const force = Math.min(Math.sqrt(diffX*diffX + diffY*diffY) / 100, 1) * SPEED * 2;
      
      // Update head direction
      closestHead.dirX = Math.cos(angle) * force;
      closestHead.dirY = Math.sin(angle) * force;
      
      // Show effect
      createParticles(closestHead.x, closestHead.y);
      showTooltip("Direction changed by swipe!");
    }
  }
});
  
// Initialize all sliders to minimum values
const allSliders = document.querySelectorAll('.slider');
allSliders.forEach(slider => {
  // Set slider to minimum value (except containerSize)
  if (slider.id !== 'containerSizeSlider') { // Keep container size as is
    slider.value = slider.min;
  }
  
  // Store the initial value
  slider.setAttribute('data-prev-value', slider.value);
  
  // Set initial business values
  if (slider.id === 'containerSizeSlider') {
    containerSizeValue.textContent = getBusinessValue('containerSize', parseInt(slider.value));
  } else if (slider.id === 'headSizeSlider') {
    DOT_RADIUS = parseFloat(slider.min);
    headSizeValue.textContent = getBusinessValue('headSize', parseFloat(slider.value));
  } else if (slider.id === 'trailLengthSlider') {
    MAX_TRAIL_LENGTH = parseInt(slider.min);
    trailLengthValue.textContent = getBusinessValue('trailLength', parseInt(slider.value));
  } else if (slider.id === 'speedSlider') {
    SPEED = parseFloat(slider.min);
    speedValue.textContent = getBusinessValue('speed', parseFloat(slider.value));
  } else if (slider.id === 'numHeadsSlider') {
    numHeads = parseInt(slider.min);
    numHeadsValue.textContent = getBusinessValue('numHeads', parseInt(slider.value));
  } else if (slider.id === 'waveFrequencySlider') {
    waveFrequencyFactor = parseFloat(slider.min);
    waveFrequencyValue.textContent = getBusinessValue('waveFrequency', parseFloat(slider.value));
  } else if (slider.id === 'obstacleSizeSlider') {
    customObstacleSize = parseInt(slider.min);
    obstacleSizeValue.textContent = getBusinessValue('obstacleSize', parseInt(slider.value));
  } else if (slider.id === 'obstacleSpeedSlider') {
    customObstacleSpeed = parseFloat(slider.min);
    obstacleSpeedValue.textContent = getBusinessValue('obstacleSpeed', parseFloat(slider.value));
  } else if (slider.id === 'obstaclesPerWaveSlider') {
    obstaclesRatio = parseFloat(slider.min);
    obstaclesPerWaveValue.textContent = getBusinessValue('obstaclesPerWave', parseFloat(slider.value));
  }
});
  
  // Initialize and start the game loop
  initGame();
  gameLoop();
  
  // Show initial business message
  showBusinessMessage('containerSize', null, null, "Process initialized. System ready for operation.");
  
  // Initialize controls state 
  const controlsContainer = document.querySelector('.controls-container');
  controlsContainer.style.display = 'none'; // Start with controls hidden
  

  
   // Make subsections expanded by default
  sectionHeaders.forEach(header => {
    if (!header.classList.contains('main-controls-header')) {
      const content = header.nextElementSibling;
      const icon = header.querySelector('.collapse-icon');
      content.classList.remove('collapsed');
      icon.classList.remove('collapsed');
    } else {
      const icon = header.querySelector('.collapse-icon');
      icon.classList.add('collapsed');
    }
  });
  
  // Add help functionality for objectives
const objectivesHelpIcon = document.getElementById('objectivesHelpIcon');
objectivesHelpIcon.addEventListener('click', function(event) {
  // Stop the event propagation
  event.stopPropagation();
  
  // Create help modal if it doesn't exist
  let helpModal = document.getElementById('objectivesHelpModal');
  if (!helpModal) {
    helpModal = document.createElement('div');
    helpModal.id = 'objectivesHelpModal';
    helpModal.className = 'help-modal';
helpModal.innerHTML = `
  <h4>Automation Objectives</h4>
  <p>Achieve these objectives by adjusting multiple parameters:</p>
  <ul>
    <li><strong>Documentation Coverage (95%+)</strong>: Increase both Process Documentation Level and Knowledge Base Coverage sliders</li>
    <li><strong>Process Standardization (85%+)</strong>: Increase Process Standardization and decrease Process Variability sliders</li>
    <li><strong>Reduce Manual Workload (40%+)</strong>: Decrease Manual Intervention Rate and increase Exception Handling Quality sliders</li>
  </ul>
  <p>Each objective depends on multiple factors - just like in real automation projects! Finding the right balance is key to success.</p>
  <button id="closeHelpButton">Got it</button>
`;
    document.body.appendChild(helpModal);
    

	// More reliable positioning that works across screen sizes
	const rect = objectivesHelpIcon.getBoundingClientRect();
	helpModal.style.top = (rect.top + window.scrollY - helpModal.offsetHeight - 10) + 'px';
	helpModal.style.left = (rect.left + window.scrollX - (helpModal.offsetWidth/2) + 10) + 'px';
    
	document.addEventListener('click', function closeOutside(event) {
  if (!helpModal.contains(event.target) && event.target !== objectivesHelpIcon) {
    helpModal.remove();
    document.removeEventListener('click', closeOutside);
  }
}, { once: false });
	
	// Add common callback for all sliders to update objectives
[containerSizeSlider, headSizeSlider, trailLengthSlider, obstacleSizeSlider, obstacleSpeedSlider, obstaclesPerWaveSlider].forEach(slider => {
  slider.addEventListener('input', function() {
    // Update objectives based on current slider settings
    updateObjectives();
  });
});
	
    // Add close button functionality
    document.getElementById('closeHelpButton').addEventListener('click', function() {
      helpModal.remove();
    });
  } else {
    helpModal.remove();
  }
});
  });

// Improved resetGameElementBounds function
function resetGameElementBounds() {
  // Add a safety check for canvas dimensions
  if (canvas.width === 0 || canvas.height === 0) {
    console.log('Canvas has zero dimensions, skipping bounds check');
    return;
  }
  
  // Adjust heads and their trails
  heads.forEach(head => {
    // First check if the head position is valid (not NaN)
    if (isNaN(head.x) || isNaN(head.y)) {
      head.x = canvas.width / 2;
      head.y = canvas.height / 2;
    }
    
    // Make sure heads stay within bounds with a small buffer for mobile
    const buffer = window.innerWidth <= 768 ? 2 : 0; // Extra buffer for mobile
    head.x = Math.max(DOT_RADIUS + buffer, Math.min(head.x, canvas.width - DOT_RADIUS - buffer));
    head.y = Math.max(DOT_RADIUS + buffer, Math.min(head.y, canvas.height - DOT_RADIUS - buffer));
    
    // Validate and reset trail if needed
    if (!Array.isArray(head.trail) || head.trail.length === 0) {
      head.trail = [{ x: head.x, y: head.y }];
    }
    
    // Ensure trail points stay within bounds too
    head.trail = head.trail.map(point => {
      // Check for invalid points
      if (!point || isNaN(point.x) || isNaN(point.y)) {
        return { x: head.x, y: head.y };
      }
      return {
        x: Math.min(Math.max(point.x, 0), canvas.width),
        y: Math.min(Math.max(point.y, 0), canvas.height)
      };
    });
  });
  
  // Keep static trails in bounds
  staticTrails = staticTrails.map(trail => {
    if (!Array.isArray(trail) || trail.length === 0) {
      return [];
    }
    return trail.map(point => {
      if (!point || isNaN(point.x) || isNaN(point.y)) {
        return { x: canvas.width/2, y: canvas.height/2 };
      }
      return {
        x: Math.min(Math.max(point.x, 0), canvas.width),
        y: Math.min(Math.max(point.y, 0), canvas.height)
      };
    });
  });
  
  // Keep obstacles in bounds
  obstacles.forEach(obs => {
    // Fix invalid values
    if (isNaN(obs.x)) obs.x = 0;
    if (isNaN(obs.y)) obs.y = 0;
    if (isNaN(obs.width) || obs.width <= 0) obs.width = customObstacleSize || 40;
    if (isNaN(obs.height) || obs.height <= 0) obs.height = customObstacleSize || 40;
    
    // Ensure obstacle size is reasonable for the canvas size
    // Use smaller obstacles on mobile for better performance
    const maxDimension = Math.min(canvas.width, canvas.height) / (window.innerWidth <= 768 ? 5 : 4);
    obs.width = Math.min(obs.width, maxDimension);
    obs.height = Math.min(obs.height, maxDimension);
    
    // Keep within bounds
    obs.x = Math.max(0, Math.min(obs.x, canvas.width - obs.width));
    obs.y = Math.max(0, Math.min(obs.y, canvas.height - obs.height));
  });
  
  // Force redraw
  draw();
}

// Function to handle mobile-specific sizing
function handleMobileResize() {
  const isMobile = window.innerWidth <= 768;
  const isLandscape = window.innerWidth > window.innerHeight;
  const isVerySmall = window.innerWidth <= 375;
  
  // Apply mobile-specific container sizing based on current media state
  if (isMobile) {
    if (isLandscape) {
      // Landscape mobile mode
      mazeContainer.style.height = '250px';
      mazeContainer.style.width = '100%';
    } else if (isVerySmall) {
      // Very small devices
      mazeContainer.style.height = '300px';
      mazeContainer.style.width = '100%';
    } else {
      // Standard mobile portrait
      const size = parseInt(containerSizeSlider.value);
      mazeContainer.style.height = `${size}px`;
      mazeContainer.style.width = '100%';
    }
  } else {
    // Reset to desktop sizing if needed
    const size = parseInt(containerSizeSlider.value);
    mazeContainer.style.width = `${size}px`;
    mazeContainer.style.height = `${size}px`;
  }
  
  // Update canvas size to match container
  canvas.width = mazeContainer.clientWidth;
  canvas.height = mazeContainer.clientHeight;
  
  // Ensure all game elements stay within bounds
  resetGameElementBounds();
}

window.addEventListener('resize', function() {
  // Set resize state
  isResizing = true;
  
  // Store position ratios
  const headPositions = heads.map(head => ({
    xRatio: head.x / canvas.width,
    yRatio: head.y / canvas.height,
    head: head
  }));
  
  // Fix layout to ensure controls stay visible
  fixLayoutAfterResize();
  
  // Use requestAnimationFrame to ensure we get dimensions after layout is complete
  requestAnimationFrame(() => {
    // Update canvas size to match container
    const newWidth = mazeContainer.clientWidth;
    const newHeight = mazeContainer.clientHeight;
    
    if (newWidth > 0 && newHeight > 0) {
      canvas.width = newWidth;
      canvas.height = newHeight;
      
      // Reposition heads based on ratios
      headPositions.forEach(posData => {
        posData.head.x = posData.xRatio * canvas.width;
        posData.head.y = posData.yRatio * canvas.height;
        
        // Enforce boundaries
        posData.head.x = Math.max(DOT_RADIUS + 1, Math.min(posData.head.x, canvas.width - DOT_RADIUS - 1));
        posData.head.y = Math.max(DOT_RADIUS + 1, Math.min(posData.head.y, canvas.height - DOT_RADIUS - 1));
      });
      
      // Reset obstacle positions
      obstacles.forEach(obs => {
        obs.x = Math.max(0, Math.min(obs.x, canvas.width - obs.width));
        obs.y = Math.max(0, Math.min(obs.y, canvas.height - obs.height));
      });
      
      // Force an immediate redraw
      draw();
      
      // Clear resize state
      isResizing = false;
    } else {
      // Fallback if dimensions are not available
      setTimeout(() => {
        const fallbackWidth = mazeContainer.clientWidth;
        const fallbackHeight = mazeContainer.clientHeight;
        canvas.width = fallbackWidth;
        canvas.height = fallbackHeight;
        
        // Force redraw and clear resize state
        draw();
        isResizing = false;
      }, 50);
    }
  });
});

window.addEventListener('orientationchange', function() {
  // Store positions as percentages before resizing
  const headPositions = heads.map(head => ({
    xPercent: head.x / canvas.width,
    yPercent: head.y / canvas.height,
    head: head
  }));
  
  // Wait longer for browser to update dimensions after orientation change
  setTimeout(() => {
    // Handle mobile-specific sizing for orientation
    const isMobile = window.innerWidth <= 768;
    const isLandscape = window.innerWidth > window.innerHeight;
    const isVerySmall = window.innerWidth <= 375;
    
    if (isMobile) {
      if (isLandscape) {
        // Landscape mobile mode
        mazeContainer.style.height = '250px';
        mazeContainer.style.width = '100%';
      } else if (isVerySmall) {
        // Very small devices in portrait
        mazeContainer.style.height = '300px';
        mazeContainer.style.width = '100%';
      } else {
        // Standard mobile portrait
        mazeContainer.style.height = '400px';
        mazeContainer.style.width = '100%';
      }
    }
    
    // Update canvas dimensions
    canvas.width = mazeContainer.clientWidth;
    canvas.height = mazeContainer.clientHeight;
    
    // Reposition heads based on stored percentages
    headPositions.forEach(posData => {
      posData.head.x = posData.xPercent * canvas.width;
      posData.head.y = posData.yPercent * canvas.height;
    });
    
    // Apply strict boundary enforcement
    enforceGameBoundaries();
    
    // Apply another check after a longer delay to catch any late updates
    setTimeout(enforceGameBoundaries, 500);
  }, 300); // Longer delay for orientation changes
});

function enforceGameBoundaries() {
  // Only run if boundaries check is needed
  obstacles.forEach(obs => {
    // Keep obstacles in bounds
    obs.x = Math.max(0, Math.min(obs.x, canvas.width - obs.width));
    obs.y = Math.max(0, Math.min(obs.y, canvas.height - obs.height));
  });
}

  <!-- Main Game Script - Include the script.js file -->
  </script>
  
  <!-- QR Code Container -->
<div class="qr-code-container">
  <div class="qr-code-inner">
    <h3>Scan to try on your device</h3>
    <div id="qrcode"></div>
    <p>https://carmon1985.github.io/intelligent-automation/</p>
  </div>
</div>
  
</body>
</html>
