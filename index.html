<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDS Intelligent Automation Team</title>
  <style>
    /* General Styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
      position: relative;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      font-size: 1.2rem;
    }
    .logo-image {
      height: 24px;
      margin-right: 8px;
    }
    nav ul {
      display: flex;
      list-style: none;
      gap: 30px;
      margin: 0;
      padding: 0;
    }
    nav a {
      color: #fff;
      text-decoration: none;
      font-size: 0.9rem;
      transition: color 0.3s ease;
    }
    nav a:hover {
      color: #FFD700;
    }
    .hero {
      display: flex;
      position: relative;
      min-height: 70vh;
    }
    .hero-content {
      width: 50%;
      padding: 60px 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .hero-image {
      width: 50%;
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      overflow: hidden;
    }
    .hero-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
    }
    h1 {
      font-size: 3rem;
      font-weight: 700;
      margin-bottom: 20px;
      line-height: 1.2;
    }
    .highlight {
      color: #FFD700;
      font-weight: 700;
    }
    .subheading {
      font-size: 1.4rem;
      line-height: 1.5;
      margin-bottom: 40px;
      opacity: 0.9;
    }
    .services {
      padding: 60px 0;
    }
    .services h2 {
      font-size: 2.5rem;
      color: #FFD700;
      margin-bottom: 40px;
    }
    .convai-wrapper {
      min-height: 400px;
      margin: 40px 0;
      position: relative;
      z-index: 3;
    }
    .chat-bubble {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background-color: #FFD700;
      color: #000;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
      cursor: pointer;
      z-index: 10;
    }
    
    /* Maze Game Styles */
    #mazeContainer {
      width: 500px;
      height: 500px;
      background-color: #000;
      position: relative;
      overflow: hidden;
      margin: 20px auto;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      cursor: default;
      transition: width 0.3s, height 0.3s;
    }
    .maze-title {
      text-align: center;
      color: #FFD700;
      margin-bottom: 20px;
      font-size: 1.8rem;
    }
    .maze-description {
      text-align: center;
      color: #fff;
      margin-bottom: 20px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      opacity: 0.8;
    }
    
    /* Tooltip Styles */
    #tooltip {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #FFD700;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 0.9rem;
      opacity: 1;
      transition: opacity 1s;
      display: none;
      pointer-events: none;
      z-index: 50;
    }
    
    /* Controls Styles */
    .controls-container {
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(30, 30, 30, 0.7);
      border-radius: 10px;
      border: 1px solid rgba(255, 215, 0, 0.3);
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      color: #FFD700;
    }
    .control-value {
      color: white;
      font-weight: 300;
    }
    .slider {
      width: 100%;
      height: 5px;
      -webkit-appearance: none;
      background: #333;
      outline: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: #FFD700;
      cursor: pointer;
    }
    .slider::-moz-range-thumb {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: #FFD700;
      cursor: pointer;
    }
    .game-control-wrapper {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      margin: 20px auto;
      max-width: 1100px;
    }
    #mazeContainer {
      margin: 0;
      flex: 0 0 auto;
    }
    .controls-container {
      margin: 0;
      flex: 1 1 300px;
      max-width: 350px;
      align-self: stretch;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    /* Complexity Tracker Styles */
    .complexity-container {
      margin-top: 15px;
    }
    .complexity-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      color: #FFD700;
    }
    .progress-bar {
      width: 100%;
      background: #333;
      height: 10px;
      border-radius: 5px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #FFD700;
      width: 0%;
      transition: width 0.3s;
    }
    /* Performance Metrics Styles */
    .performance-group {
      margin-bottom: 10px;
    }
    /* Clear Button Style */
    #clearButton {
      background-color: #FFD700;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #clearButton:hover {
      background-color: #e6c200;
    }
    /* Overlay for complexity goal reached (covers only the maze container) */
    #overlayMessage {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #FFD700;
      font-size: 1.8rem;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #restartButton {
      margin-top: 20px;
      background-color: #FFD700;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #restartButton:hover {
      background-color: #e6c200;
    }
    /* Obstacles drawn as fixed-size squares with same color as heads */
    .obstacle {
      fill: #ecd404;
    }
    /* Media query for mobile screens */
    @media (max-width: 768px) {
      .game-control-wrapper {
        flex-direction: column;
        align-items: center;
      }
      .controls-container {
        max-width: 500px;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <img src="LogoIA.png" alt="Logo" class="logo-image">
        GDS Intelligent Automation Team
      </div>
      <nav>
        <ul>
          <li><a href="#">Home</a></li>
          <li><a href="#">What Do We Do</a></li>
          <li><a href="#">Case Studies</a></li>
          <li><a href="#">Contact</a></li>
        </ul>
      </nav>
    </header>
    
    <section class="hero">
      <div class="hero-content">
        <h1>Transform your business with <span class="highlight">Intelligent Automation</span>: Efficiency, Innovation, and Growth at your fingertips</h1>
      </div>
      <div class="hero-image">
        <img src="lines.jpg" alt="Circuit Lines" />
      </div>
    </section>
    
    <section class="services">
      
      <!-- Maze Game Section -->
      <h3 class="maze-title">Intelligent Automation Pathfinder</h3>
      <p class="maze-description">Explore how algorithms create efficient paths through complex problems. Click on the moving dot(s) to change their direction and watch as they form a complex, evolving maze.</p>
      <div class="game-control-wrapper">
        <!-- Maze Container on the left -->
        <div id="mazeContainer">
          <!-- Tooltip for narration -->
          <div id="tooltip"></div>
          <!-- Overlay message inside mazeContainer so it covers only the game area -->
          <div id="overlayMessage">
            Discover how our Intelligent Automation department can guide you through the maze of technology and process complexity. Use our voice bot to contact us and start your journey to streamlined innovation!
            <button id="restartButton">Start Your Journey Again</button>
          </div>
        </div>
        <!-- Controls Container on the right -->
        <div class="controls-container">
          <div class="control-group">
            <div class="control-label">
              <span>Container Size</span>
              <span class="control-value" id="containerSizeValue">500px</span>
            </div>
            <input type="range" min="450" max="800" value="500" class="slider" id="containerSizeSlider">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Head Size</span>
              <span class="control-value" id="headSizeValue">7.5px</span>
            </div>
            <input type="range" min="3" max="20" value="7.5" step="0.5" class="slider" id="headSizeSlider">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Trail Length</span>
              <span class="control-value" id="trailLengthValue">2000</span>
            </div>
            <input type="range" min="1500" max="8000" value="4000" step="100" class="slider" id="trailLengthSlider">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Speed</span>
              <span class="control-value" id="speedValue">2</span>
            </div>
            <input type="range" min="0.5" max="8" value="2" step="0.5" class="slider" id="speedSlider">
          </div>
          <div class="control-group">
            <div class="control-label">
              <span>Number of Heads</span>
              <span class="control-value" id="numHeadsValue">1</span>
            </div>
            <input type="range" min="1" max="3" value="1" step="1" class="slider" id="numHeadsSlider">
          </div>
          <div class="control-group">
            <button id="clearButton">Clear Maze</button>
          </div>
          <!-- Complexity Tracker -->
          <div class="control-group complexity-container">
            <div class="complexity-label">
              <span>Complexity</span>
              <span class="control-value" id="complexityValue">0</span>
            </div>
            <div class="progress-bar">
              <div class="progress" id="complexityProgress"></div>
            </div>
          </div>
          <!-- Performance Metrics -->
          <div class="control-group performance-group">
            <div class="control-label">
              <span>Directional Changes</span>
              <span class="control-value" id="directionChangesValue">0</span>
            </div>
          </div>
          <div class="control-group performance-group">
            <div class="control-label">
              <span>Collisions</span>
              <span class="control-value" id="collisionsValue">0</span>
            </div>
          </div>
          <div class="control-group performance-group">
            <div class="control-label">
              <span>Total Distance</span>
              <span class="control-value" id="totalDistanceValue">0</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- ElevenLabs Convai Widget Container -->
      <div class="convai-wrapper">
        <elevenlabs-convai agent-id="GzXUUK45tH3zF6kwllQH"></elevenlabs-convai>
      </div>
    </section>
  </div>
  
  <!-- Maze Game Script -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Get maze container and controls elements
      const mazeContainer = document.getElementById('mazeContainer');
      const containerSizeSlider = document.getElementById('containerSizeSlider');
      const headSizeSlider = document.getElementById('headSizeSlider');
      const trailLengthSlider = document.getElementById('trailLengthSlider');
      const speedSlider = document.getElementById('speedSlider');
      const numHeadsSlider = document.getElementById('numHeadsSlider');
      const clearButton = document.getElementById('clearButton');
      const restartButton = document.getElementById('restartButton');
      const complexityValue = document.getElementById('complexityValue');
      const complexityProgress = document.getElementById('complexityProgress');
      const overlayMessage = document.getElementById('overlayMessage');
      const tooltip = document.getElementById('tooltip');
      
      const containerSizeValue = document.getElementById('containerSizeValue');
      const headSizeValue = document.getElementById('headSizeValue');
      const trailLengthValue = document.getElementById('trailLengthValue');
      const speedValue = document.getElementById('speedValue');
      const numHeadsValue = document.getElementById('numHeadsValue');
      
      // Create and append canvas
      const canvas = document.createElement('canvas');
      canvas.width = mazeContainer.clientWidth;
      canvas.height = mazeContainer.clientHeight;
      mazeContainer.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      
      // Initialize variables from slider values
      let DOT_RADIUS = parseFloat(headSizeSlider.value);
      let MAX_TRAIL_LENGTH = parseInt(trailLengthSlider.value);
      let SPEED = parseFloat(speedSlider.value);
      const LINE_WIDTH = 2;
      
      // Performance metrics
      let directionalChanges = 0;
      let collisionCount = 0;
      let totalDistance = 0;
      
      // Complexity tracker goal set to 30000
      const COMPLEXITY_GOAL = 30000;
      let complexityGoalReached = false;
      
      // Thresholds for business messages
      const THRESHOLD1 = 5000;
      const THRESHOLD2 = 15000;
      let message1Displayed = false;
      let message2Displayed = false;
      
      // Obstacles array for additional walls (fixed size squares)
      let obstacles = [];
      const OBSTACLE_SIZE = 40;
      
      // Maintain static trails for removed heads (their trails persist)
      let staticTrails = [];
      
      // Initialize multiple heads state
      let heads = []; // Each head: { x, y, dirX, dirY, trail }
      let numHeads = parseInt(numHeadsSlider.value);
      if(numHeads < 1) numHeads = 1;
      
      // Declare tooltip timer variable and current tooltip priority
      let lastTooltipTime = 0;
      let currentTooltipPriority = 0; // 3 = high, 2 = medium, 1 = low
      let tooltipTimeout = null;
      
      // showTooltip function with priority: all messages show for 3 seconds.
      // High priority messages override lower ones.
      function showTooltip(message, priority) {
        const nowTime = Date.now();
        if (currentTooltipPriority > priority && tooltip.style.display === 'block') {
          return;
        }
        if (tooltipTimeout) {
          clearTimeout(tooltipTimeout);
        }
        tooltip.textContent = message;
        tooltip.style.opacity = 1;
        tooltip.style.display = 'block';
        currentTooltipPriority = priority;
        tooltipTimeout = setTimeout(() => {
          tooltip.style.opacity = 0;
          setTimeout(() => {
            tooltip.style.display = 'none';
            currentTooltipPriority = 0;
          }, 1000);
        }, 3000);
        lastTooltipTime = nowTime;
      }
      
      // Initialize heads array based on numHeads without clearing trails
      function initHeads() {
        while (heads.length < numHeads) {
          let startX = heads.length > 0 ? heads[0].x : canvas.width / 2;
          let startY = heads.length > 0 ? heads[0].y : canvas.height / 2;
          heads.push({
            x: startX,
            y: startY,
            dirX: Math.random() > 0.5 ? SPEED : -SPEED,
            dirY: Math.random() > 0.5 ? SPEED : -SPEED,
            trail: [{ x: startX, y: startY }]
          });
          directionalChanges++;
          changeDirection(heads.length - 1);
          showTooltip("Operational dynamics evolving—systems recalibrate to manage rising process complexity.", 3);
        }
        console.log("Heads initialized:", heads);
        while (heads.length > numHeads) {
          const removed = heads.pop();
          staticTrails.push(removed.trail);
        }
      }
      initHeads();
      
      // Update number of heads without clearing maze
      numHeadsSlider.addEventListener('input', function() {
        numHeads = parseInt(this.value);
        numHeadsValue.textContent = numHeads;
        initHeads();
        updatePerformanceMetrics();
        showTooltip("Resource allocation optimized—team capacity adjusted.", 2);
      });
      
      // Clear maze button resets active heads' trails, static trails, obstacles, and metrics
      clearButton.addEventListener('click', function() {
        heads.forEach(head => {
          head.trail = [];
          head.x = canvas.width / 2;
          head.y = canvas.height / 2;
          head.trail.push({ x: head.x, y: head.y });
        });
        staticTrails = [];
        obstacles = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        directionalChanges = 0;
        collisionCount = 0;
        updateComplexity(0);
        updatePerformanceMetrics();
        complexityGoalReached = false;
        message1Displayed = false;
        message2Displayed = false;
        overlayMessage.style.display = 'none';
      });
      
      // Restart button on overlay
      restartButton.addEventListener('click', function() {
        clearButton.click();
      });
      
      // Update container size when slider changes (min 450)
      containerSizeSlider.addEventListener('input', function() {
        const size = this.value;
        mazeContainer.style.width = `${size}px`;
        mazeContainer.style.height = `${size}px`;
        containerSizeValue.textContent = `${size}px`;
        canvas.width = size;
        canvas.height = size;
        heads.forEach(head => {
          if (head.x > canvas.width || head.y > canvas.height) {
            head.x = canvas.width / 2;
            head.y = canvas.height / 2;
          }
        });
        showTooltip("Infrastructure scaling optimized.", 2);
      });
      
      // Update head size when slider changes
      headSizeSlider.addEventListener('input', function() {
        DOT_RADIUS = parseFloat(this.value);
        headSizeValue.textContent = `${DOT_RADIUS}px`;
        showTooltip("Precision in process monitoring enhanced.", 2);
      });
      
      // Update trail length when slider changes (min 1200)
      trailLengthSlider.addEventListener('input', function() {
        MAX_TRAIL_LENGTH = parseInt(this.value);
        trailLengthValue.textContent = MAX_TRAIL_LENGTH;
        heads.forEach(head => {
          if (head.trail.length > MAX_TRAIL_LENGTH) {
            head.trail = head.trail.slice(head.trail.length - MAX_TRAIL_LENGTH);
          }
        });
        staticTrails.forEach((trail, index) => {
          if (trail.length > MAX_TRAIL_LENGTH) {
            staticTrails[index] = trail.slice(trail.length - MAX_TRAIL_LENGTH);
          }
        });
        showTooltip("Workflow pathways expanded.", 2);
      });
      
      // Update speed when slider changes
      speedSlider.addEventListener('input', function() {
        const newSpeed = parseFloat(this.value);
        heads.forEach(head => {
          const angle = Math.atan2(head.dirY, head.dirX);
          head.dirX = Math.cos(angle) * newSpeed;
          head.dirY = Math.sin(angle) * newSpeed;
        });
        SPEED = newSpeed;
        speedValue.textContent = SPEED;
        showTooltip("Operational tempo accelerated.", 2);
      });
      
      // Particle effect for spell applied only to clicked head
      let particles = [];
      let isEffectActive = false;
      
      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 3 + 1;
          this.speedX = Math.random() * 3 - 1.5;
          this.speedY = Math.random() * 3 - 1.5;
          this.color = this.getRandomColor();
          this.life = 100;
        }
        getRandomColor() {
          const colors = ['#ecd404', '#ffffff', '#706623'];
          return colors[Math.floor(Math.random() * colors.length)];
        }
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.life -= 1;
          if (this.life > 0 && this.size > 0.2) {
            this.size -= 0.05;
          }
        }
        draw() {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      
      // Create spell effect only for the clicked head
      function createSpellEffect(head) {
        isEffectActive = true;
        for (let i = 0; i < 50; i++) {
          particles.push(new Particle(head.x, head.y));
        }
      }
      
      // Determine if a click is within any head's area; return index or -1
      function isPointInAnyDot(x, y) {
        for (let i = 0; i < heads.length; i++) {
          const head = heads[i];
          const distance = Math.sqrt((x - head.x) ** 2 + (y - head.y) ** 2);
          if (distance <= DOT_RADIUS * 2) {
            return i;
          }
        }
        return -1;
      }
      
      canvas.addEventListener('click', function(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const headIndex = isPointInAnyDot(x, y);
        if (headIndex !== -1) {
          changeDirection(headIndex);
          createSpellEffect(heads[headIndex]);
          updatePerformanceMetrics();
          // Add meaningful message when head is clicked
          showTooltip("Strategic action initiated—your initiative is being processed.", 2);
        }
      });
      
      canvas.addEventListener('touchstart', function(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = event.touches[0].clientX - rect.left;
        const y = event.touches[0].clientY - rect.top;
        const headIndex = isPointInAnyDot(x, y);
        if (headIndex !== -1) {
          changeDirection(headIndex);
          createSpellEffect(heads[headIndex]);
          updatePerformanceMetrics();
          showTooltip("Strategic action initiated—your initiative is being processed.", 2);
        }
      });
      
      // Modified changeDirection that accepts a head index and increments directional changes
      function changeDirection(headIndex) {
        const head = heads[headIndex];
        const angle = (Math.random() * 45 + 45) * (Math.PI / 180);
        const currentAngle = Math.atan2(head.dirY, head.dirX);
        const newAngle = currentAngle + (Math.random() > 0.5 ? angle : -angle);
        head.dirX = Math.cos(newAngle) * SPEED;
        head.dirY = Math.sin(newAngle) * SPEED;
        directionalChanges++;
      }
      
      // Check for collisions between heads and adjust direction if they collide
      function checkHeadCollisions() {
        for (let i = 0; i < heads.length; i++) {
          for (let j = i + 1; j < heads.length; j++) {
            const dx = heads[i].x - heads[j].x;
            const dy = heads[i].y - heads[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < DOT_RADIUS * 2) {
              let randomAngleDeg = Math.random() * (180 - 5) + 5;
              let randomAngle = randomAngleDeg * (Math.PI / 180);
              let currentAngleI = Math.atan2(heads[i].dirY, heads[i].dirX);
              let newAngleI = currentAngleI + (Math.random() > 0.5 ? randomAngle : -randomAngle);
              heads[i].dirX = Math.cos(newAngleI) * SPEED;
              heads[i].dirY = Math.sin(newAngleI) * SPEED;
              let currentAngleJ = Math.atan2(heads[j].dirY, heads[j].dirX);
              let newAngleJ = currentAngleJ + (Math.random() > 0.5 ? randomAngle : -randomAngle);
              heads[j].dirX = Math.cos(newAngleJ) * SPEED;
              heads[j].dirY = Math.sin(newAngleJ) * SPEED;
              collisionCount++;
            }
          }
        }
      }
      
      // Update obstacles based on complexity thresholds: 1 obstacle when complexity >=10K, 3 when >=20K
      function updateObstacles(complexity) {
        let desiredObstacles = 0;
        if (complexity >= 20000) {
          desiredObstacles = 3;
        } else if (complexity >= 10000) {
          desiredObstacles = 1;
        }
        while (obstacles.length < desiredObstacles) {
          let obsSize = OBSTACLE_SIZE;
          let obsX = Math.random() * (canvas.width - obsSize);
          let obsY = Math.random() * (canvas.height - obsSize);
          obstacles.push({ x: obsX, y: obsY, width: obsSize, height: obsSize });
          if (obstacles.length === 1) {
            showTooltip("A critical operational challenge has emerged—strategic obstacles are now present.", 3);
          } else if (obstacles.length === 3) {
            showTooltip("Multiple market barriers are complicating operations—advanced automation is essential.", 3);
          }
        }
      }
      
      // Update function with collision handling
      function update() {
        heads.forEach(head => {
          head.x += head.dirX;
          head.y += head.dirY;
          // Check collision with left/right walls
          if (head.x <= 0 || head.x >= canvas.width) {
            const randomAngleDeg = Math.random() * (180 - 5) + 5;
            const randomAngle = randomAngleDeg * (Math.PI / 180);
            const currentAngle = Math.atan2(head.dirY, head.dirX);
            const newAngle = currentAngle + (Math.random() > 0.5 ? randomAngle : -randomAngle);
            head.dirX = Math.cos(newAngle) * SPEED;
            head.dirY = Math.sin(newAngle) * SPEED;
            head.x = Math.max(0, Math.min(canvas.width, head.x));
            collisionCount++;
          }
          // Check collision with top/bottom walls
          if (head.y <= 0 || head.y >= canvas.height) {
            const randomAngleDeg = Math.random() * (180 - 5) + 5;
            const randomAngle = randomAngleDeg * (Math.PI / 180);
            const currentAngle = Math.atan2(head.dirY, head.dirX);
            const newAngle = currentAngle + (Math.random() > 0.5 ? randomAngle : -randomAngle);
            head.dirX = Math.cos(newAngle) * SPEED;
            head.dirY = Math.sin(newAngle) * SPEED;
            head.y = Math.max(0, Math.min(canvas.height, head.y));
            collisionCount++;
          }
          // Check collision with obstacles
          obstacles.forEach(obstacle => {
            if (head.x + DOT_RADIUS > obstacle.x && head.x - DOT_RADIUS < obstacle.x + obstacle.width &&
                head.y + DOT_RADIUS > obstacle.y && head.y - DOT_RADIUS < obstacle.y + obstacle.height) {
              const randomAngleDeg = Math.random() * (180 - 5) + 5;
              const randomAngle = randomAngleDeg * (Math.PI / 180);
              const currentAngle = Math.atan2(head.dirY, head.dirX);
              const newAngle = currentAngle + (Math.random() > 0.5 ? randomAngle : -randomAngle);
              head.dirX = Math.cos(newAngle) * SPEED;
              head.dirY = Math.sin(newAngle) * SPEED;
              collisionCount++;
              if (Math.random() < 0.3) {
                showTooltip("Navigating market turbulence—strategic recalibrations are in progress.", 1);
              }
            }
          });
          head.trail.push({ x: head.x, y: head.y });
          if (head.trail.length > MAX_TRAIL_LENGTH) {
            head.trail.shift();
          }
        });
        
        // Check for head-to-head collisions
        checkHeadCollisions();
        
        if (isEffectActive) {
          for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) {
              particles.splice(i, 1);
            }
          }
          if (particles.length === 0) {
            isEffectActive = false;
          }
        }
        
        // Compute total trail length from active heads and static trails
        let computedDistance = 0;
        heads.forEach(head => {
          computedDistance += computeTrailLength(head.trail);
        });
        staticTrails.forEach(trail => {
          computedDistance += computeTrailLength(trail);
        });
        totalDistance = computedDistance;
        
        // Complexity: weighted sum of (totalDistance/10) + (directionalChanges * 50) + (collisionCount * 50) + (obstacles.length * 100)
        let complexity = totalDistance / 10 + directionalChanges * 50 + collisionCount * 50 + obstacles.length * 100;
        updateComplexity(complexity);
        updatePerformanceMetrics();
        updateObstacles(complexity);
      }
      
      // Function to compute trail length from an array of points
      function computeTrailLength(trail) {
        let length = 0;
        for (let i = 0; i < trail.length - 1; i++) {
          const dx = trail[i + 1].x - trail[i].x;
          const dy = trail[i + 1].y - trail[i].y;
          length += Math.sqrt(dx * dx + dy * dy);
        }
        return length;
      }
      
      // Update complexity tracker and display threshold messages
      function updateComplexity(complexity) {
        const percent = Math.min((complexity / COMPLEXITY_GOAL) * 100, 100);
        complexityProgress.style.width = percent + '%';
        complexityValue.textContent = Math.floor(complexity);
        if (complexity >= THRESHOLD1 && !message1Displayed) {
          message1Displayed = true;
          showTooltip("Our operational landscape has reached a critical threshold—processes are increasingly challenging to navigate.", 3);
        }
        if (complexity >= THRESHOLD2 && !message2Displayed) {
          message2Displayed = true;
          showTooltip("Complexity escalated significantly—advanced automation strategies are vital for overcoming these barriers.", 3);
        }
        if (complexity >= COMPLEXITY_GOAL && !complexityGoalReached) {
          complexityGoalReached = true;
          overlayMessage.style.display = 'flex';
        }
      }
      
      // Update performance metrics display
      function updatePerformanceMetrics() {
        document.getElementById('directionChangesValue').textContent = directionalChanges;
        document.getElementById('collisionsValue').textContent = collisionCount;
        document.getElementById('totalDistanceValue').textContent = Math.floor(totalDistance);
      }
      
      // Draw function
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw static trails first
        staticTrails.forEach(trail => {
          for (let i = 0; i < trail.length - 1; i++) {
            const opacity = i / trail.length;
            ctx.beginPath();
            ctx.moveTo(trail[i].x, trail[i].y);
            ctx.lineTo(trail[i + 1].x, trail[i + 1].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
          }
        });
        
        // Draw obstacles as squares with same color as heads
        obstacles.forEach(obstacle => {
          ctx.fillStyle = "#ecd404";
          ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        });
        
        // Draw trails for active heads
        heads.forEach(head => {
          for (let i = 0; i < head.trail.length - 1; i++) {
            const opacity = i / head.trail.length;
            ctx.beginPath();
            ctx.moveTo(head.trail[i].x, head.trail[i].y);
            ctx.lineTo(head.trail[i + 1].x, head.trail[i + 1].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
          }
        });
        
        // Draw particles
        if (isEffectActive) {
          particles.forEach(particle => particle.draw());
        }
        
        // Draw active head dots
        heads.forEach(head => {
          ctx.beginPath();
          ctx.arc(head.x, head.y, DOT_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = '#ecd404';
          ctx.fill();
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ecd404';
          ctx.fill();
          ctx.shadowBlur = 0;
        });
      }
      
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }
      
      gameLoop();
    });
  </script>
  
  <!-- ElevenLabs Convai Widget Script -->
  <script src="https://elevenlabs.io/convai-widget/index.js" type="text/javascript"></script>
</body>
</html>
