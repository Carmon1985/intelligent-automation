<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDS Intelligent Automation Team</title>
  <style>
    /* Main site styling */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .logo {
      display: flex;
      align-items: center;
      font-size: 1.5rem;
      color: #fff;
    }
    
    .logo-image {
      height: 40px;
      margin-right: 10px;
    }
    
    nav ul {
      display: flex;
      list-style: none;
      padding: 0;
    }
    
    nav ul li {
      margin-left: 20px;
    }
    
    nav ul li a {
      color: #fff;
      text-decoration: none;
    }
    
    .hero {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      padding: 60px 0;
      align-items: center;
    }
    
    .hero-content h1 {
      font-size: 2.5rem;
      line-height: 1.2;
    }
    
    .highlight {
      color: #FFD700;
    }
    
    .hero-image img {
      width: 100%;
      border-radius: 8px;
    }
    
    .services {
      padding: 40px 0;
    }
    
    .maze-title {
      font-size: 2rem;
      color: #FFD700;
      text-align: center;
      margin-bottom: 10px;
    }
    
    .maze-description {
      text-align: center;
      max-width: 800px;
      margin: 0 auto 40px;
    }
    
    .convai-wrapper {
      margin-top: 60px;
    }
    
    /* Game styles */
    .game-control-wrapper {
      display: grid;
      grid-template-columns: auto 1fr;
      grid-template-areas: 
        "maze controls"
        "process process";
      gap: 20px;
      margin: 20px auto;
      overflow: hidden; /* Prevent jumping during resize */
    }
    
    #mazeContainer {
      grid-area: maze;
      width: 530px;
      height: 570px;
      background-color: #000;
      position: relative;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      border: none;
      overflow: hidden;
      transition: width 0.3s ease, height 0.3s ease; /* Smooth transition */
    }
    
    .controls-wrapper {
      grid-area: controls;
    }
    
    .controls-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 15px;
    }
    
    .advanced-controls, .standard-controls, .process-load-container {
      background-color: #222;
      border: none;
      padding: 15px;
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding-bottom: 8px;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .section-header h3 {
      margin: 0;
      color: #FFD700;
      font-size: 1.2rem;
    }
    
    .main-controls-header {
      background-color: #222;
      border-radius: 4px;
      padding: 10px 15px;
      margin-bottom: 0;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      cursor: pointer;
    }
    
    .collapse-icon {
      color: #FFD700;
      transition: transform 0.3s ease;
    }
    
    .collapse-icon.collapsed {
      transform: rotate(-90deg);
    }
    
    .section-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: 500px;
      padding: 0 5px;
    }
    
    .section-content.collapsed {
      max-height: 0;
    }
    
    h3 {
      color: #FFD700;
      margin-top: 0;
    }
    
    .control-group {
      margin-bottom: 20px;
    }
    
    .control-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      color: #FFD700;
    }
    
    .control-value {
      color: white;
    }
    
    .slider {
      width: 100%;
      height: 5px;
      -webkit-appearance: none;
      background: #333;
      outline: none;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid #FFD700;
      margin: 8px 0;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: #FFD700;
      cursor: pointer;
    }
    
    .process-load-container {
      grid-area: process;
      margin-top: 20px;
    }
    
    .progress-bar, .wave-progress-bar {
      width: 100%;
      background: #333;
      height: 10px;
      border-radius: 5px;
      overflow: hidden;
      border: 1px solid #FFD700;
    }
    
    .progress, .wave-progress {
      height: 100%;
      background: #FFD700;
      width: 0%;
      transition: width 0.3s;
    }
    
    .wave-progress {
      width: 100%;
    }
    
    #clearButton, #restartButton {
      background-color: #FFD700;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
    }
    
    #tooltip {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #FFD700;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 0.9rem;
      opacity: 1;
      display: none;
      z-index: 50;
    }
    
    /* Business message style */
    .business-message {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      text-align: center;
      color: #FFD700;
      font-size: 1rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 15px;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
    }
    
    #overlayMessage {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #FFD700;
      font-size: 1.8rem;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    
    /* Media query for mobile screens */
    @media (max-width: 1024px) {
      .game-control-wrapper {
        grid-template-columns: 1fr;
        grid-template-areas: 
          "maze"
          "controls"
          "process";
      }
      
      #mazeContainer {
        width: 100%;
        height: 500px;
        max-width: 500px;
        margin: 0 auto;
      }
      
      .controls-container {
        grid-template-columns: 1fr;
      }
      
      .hero {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 768px) {
      .game-control-wrapper {
        grid-template-columns: 1fr;
      }
      
      .controls-container {
        grid-template-columns: 1fr;
      }
      
      #mazeContainer {
        width: 100%;
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <img src="LogoIA.png" alt="Logo" class="logo-image">
        GDS Intelligent Automation Team
      </div>
      <nav>
        <ul>
          <li><a href="#">Home</a></li>
          <li><a href="#">What Do We Do</a></li>
          <li><a href="#">Case Studies</a></li>
          <li><a href="#">Contact</a></li>
        </ul>
      </nav>
    </header>
    
    <section class="hero">
      <div class="hero-content">
        <h1>Transform your business with <span class="highlight">Intelligent Automation</span>: Efficiency, Innovation, and Growth at your fingertips</h1>
      </div>
      <div class="hero-image">
        <img src="lines.jpg" alt="Circuit Lines" />
      </div>
    </section>
    
    <section class="services">
      
      <!-- Maze Game Section -->
      <h3 class="maze-title">Intelligent Automation Pathfinder</h3>
      <p class="maze-description">Explore how automated processes navigate through complex business challenges. Click on the moving dot(s) to change their direction, neutralize obstacles with a click, and observe how they create evolving process pathways. Adjust controls to optimize performance and manage strategic challenges through the system.</p>
      
      <!-- Game Control Wrapper -->
      <div class="game-control-wrapper">
        <div id="mazeContainer">
          <div id="tooltip"></div>
          <div class="business-message" id="businessMessage"></div>
          <div id="overlayMessage">
            Discover how our Intelligent Automation department can guide you through the maze of technology and process complexity. Use our voice bot to contact us and start your journey to streamlined innovation!
            <button id="restartButton">Start Your Jurney Again</button>
          </div>
        </div>
        
        <div class="controls-wrapper">
          <div class="section-header main-controls-header">
            <h3>Controls Panel</h3>
            <span class="collapse-icon">▼</span>
          </div>
          <div class="controls-container">
            <!-- Standard Controls -->
            <div class="standard-controls">
              <div class="section-header">
                <h3>Standard Controls</h3>
                <span class="collapse-icon">▼</span>
              </div>
              <div class="section-content">
                <div class="control-group">
                  <div class="control-label">
                    <span>Container Size</span>
                    <span class="control-value" id="containerSizeValue">570px</span>
                  </div>
                  <input type="range" min="450" max="800" value="570" class="slider" id="containerSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Head Size</span>
                    <span class="control-value" id="headSizeValue">7.5px</span>
                  </div>
                  <input type="range" min="3" max="20" value="7.5" step="0.5" class="slider" id="headSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Trail Length</span>
                    <span class="control-value" id="trailLengthValue">2000</span>
                  </div>
                  <input type="range" min="1000" max="8000" value="2000" step="100" class="slider" id="trailLengthSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Speed</span>
                    <span class="control-value" id="speedValue">2</span>
                  </div>
                  <input type="range" min="0.5" max="8" value="2" step="0.5" class="slider" id="speedSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Number of Heads</span>
                    <span class="control-value" id="numHeadsValue">1</span>
                  </div>
                  <input type="range" min="1" max="3" value="1" step="1" class="slider" id="numHeadsSlider">
                </div>
                <button id="clearButton">Clear Maze</button>
              </div>
            </div>
            
            <!-- Advanced Controls: Business Parameters -->
            <div class="advanced-controls">
              <div class="section-header">
                <h3>Business Parameters</h3>
                <span class="collapse-icon">▼</span>
              </div>
              <div class="section-content">
                <div class="control-group">
                  <div class="control-label">
                    <span>Wave Frequency</span>
                    <span class="control-value" id="waveFrequencyValue">1.0</span>
                  </div>
                  <input type="range" min="0.5" max="2" value="1" step="0.1" class="slider" id="waveFrequencySlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Obstacle Size</span>
                    <span class="control-value" id="obstacleSizeValue">40px</span>
                  </div>
                  <input type="range" min="20" max="80" value="40" class="slider" id="obstacleSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Obstacle Speed</span>
                    <span class="control-value" id="obstacleSpeedValue">1.0</span>
                  </div>
                  <input type="range" min="0.5" max="3.0" value="1.0" step="0.1" class="slider" id="obstacleSpeedSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Obstacles per Wave Ratio</span>
                    <span class="control-value" id="obstaclesPerWaveValue">1.0</span>
                  </div>
                  <input type="range" min="0.5" max="2.0" value="1.0" step="0.1" class="slider" id="obstaclesPerWaveSlider">
                </div>
                <div class="wave-countdown-container">
                  <div class="control-label">
                    <span>Next Wave Countdown</span>
                  </div>
                  <div class="wave-progress-bar">
                    <div class="wave-progress" id="waveCountdownProgress"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Process Load Tracker -->
        <div class="process-load-container">
          <div class="section-header">
            <h3>Process Load</h3>
            <span class="collapse-icon">▼</span>
          </div>
          <div class="section-content">
            <div class="control-label">
              <span>Process Load</span>
              <span class="control-value" id="complexityValueDisplay">0</span>
            </div>
            <div class="progress-bar">
              <div class="progress" id="complexityProgress"></div>
            </div>
            <div class="control-label">
              <span>Collisions</span>
              <span class="control-value" id="collisionsValue">0</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- ElevenLabs Convai Widget Container -->
      <div class="convai-wrapper">
        <elevenlabs-convai agent-id="GzXUUK45tH3zF6kwllQH"></elevenlabs-convai>
      </div>
    </section>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Basic setup
      const mazeContainer = document.getElementById('mazeContainer');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size to match container
      canvas.width = mazeContainer.clientWidth;
      canvas.height = mazeContainer.clientHeight;
      mazeContainer.appendChild(canvas);
      
      // UI elements
      const containerSizeSlider = document.getElementById('containerSizeSlider');
      const headSizeSlider = document.getElementById('headSizeSlider');
      const trailLengthSlider = document.getElementById('trailLengthSlider');
      const speedSlider = document.getElementById('speedSlider');
      const numHeadsSlider = document.getElementById('numHeadsSlider');
      const waveFrequencySlider = document.getElementById('waveFrequencySlider');
      const obstacleSizeSlider = document.getElementById('obstacleSizeSlider');
      const obstacleSpeedSlider = document.getElementById('obstacleSpeedSlider');
      const obstaclesPerWaveSlider = document.getElementById('obstaclesPerWaveSlider');
      const waveCountdownProgress = document.getElementById('waveCountdownProgress');
      const clearButton = document.getElementById('clearButton');
      const restartButton = document.getElementById('restartButton');
      const tooltip = document.getElementById('tooltip');
      const businessMessage = document.getElementById('businessMessage');
      const overlayMessage = document.getElementById('overlayMessage');
      const sectionHeaders = document.querySelectorAll('.section-header');
      
      // Display elements
      const containerSizeValue = document.getElementById('containerSizeValue');
      const headSizeValue = document.getElementById('headSizeValue');
      const trailLengthValue = document.getElementById('trailLengthValue');
      const speedValue = document.getElementById('speedValue');
      const numHeadsValue = document.getElementById('numHeadsValue');
      const waveFrequencyValue = document.getElementById('waveFrequencyValue');
      const obstacleSizeValue = document.getElementById('obstacleSizeValue');
      const obstacleSpeedValue = document.getElementById('obstacleSpeedValue');
      const obstaclesPerWaveValue = document.getElementById('obstaclesPerWaveValue');
      const complexityProgress = document.getElementById('complexityProgress');
      const complexityValueDisplay = document.getElementById('complexityValueDisplay');
      const collisionsValue = document.getElementById('collisionsValue');
      
      // Game parameters
      let DOT_RADIUS = parseFloat(headSizeSlider.value);
      let MAX_TRAIL_LENGTH = parseInt(trailLengthSlider.value);
      let SPEED = parseFloat(speedSlider.value);
      let numHeads = parseInt(numHeadsSlider.value);
      let waveFrequencyFactor = parseFloat(waveFrequencySlider.value);
      let customObstacleSize = parseInt(obstacleSizeSlider.value);
      let customObstacleSpeed = parseFloat(obstacleSpeedSlider.value);
      let obstaclesRatio = parseFloat(obstaclesPerWaveSlider.value);
      const LINE_WIDTH = 2;
      
      // Game state
      let heads = [];
      let obstacles = [];
      let staticTrails = [];
      let particles = [];
      let isEffectActive = false;
      let collisionCount = 0;
      let headCollisionCount = 0; // Separate counter for head collisions
      let lastFrameTime = performance.now();
      let waveCountdownMax = 15000 / waveFrequencyFactor;
      let waveCountdown = waveCountdownMax;
      let messageTimeout = null;
      let controlsVisible = false;
      
      // Constants
      const PROCESS_LOAD_GOAL = 2000;
      let processLoadGoalReached = false;
      
      // Set up collapsible sections
      sectionHeaders.forEach(header => {
        if (header.classList.contains('main-controls-header')) {
          // Special handling for main controls header
          header.addEventListener('click', function() {
            const controlsContainer = document.querySelector('.controls-container');
            const icon = this.querySelector('.collapse-icon');
            
            if (controlsContainer.style.display === 'none' || controlsContainer.style.display === '') {
              controlsContainer.style.display = 'grid';
              icon.classList.remove('collapsed');
              controlsVisible = true;
            } else {
              controlsContainer.style.display = 'none';
              icon.classList.add('collapsed');
              controlsVisible = false;
            }
          });
        } else {
          // Regular section headers
          header.addEventListener('click', function() {
            const content = this.nextElementSibling;
            const icon = this.querySelector('.collapse-icon');
            
            if (content.classList.contains('collapsed')) {
              content.classList.remove('collapsed');
              icon.classList.remove('collapsed');
            } else {
              content.classList.add('collapsed');
              icon.classList.add('collapsed');
            }
          });
        }
      });
      
      // Business messages for different controls
      const businessMessages = {
        containerSize: [
          "Infrastructure scaling optimized to accommodate growing business needs.",
          "Digital workspace resized for enhanced operational visibility.",
          "Platform capacity adjusted to align with enterprise requirements."
        ],
        headSize: [
          "Precision parameter calibrated for optimal process execution.",
          "Agent interaction radius modified to enhance engagement effectiveness.",
          "Resource allocation granularity refined for task execution."
        ],
        trailLength: [
          "Process history retention policy updated to optimize system performance.",
          "Workflow trace depth recalibrated for comprehensive analytics.",
          "Data persistence parameters adjusted to align with audit requirements."
        ],
        speed: [
          "Operational velocity adjusted to match market conditions.",
          "Process execution cadence optimized for current workload.",
          "Throughput parameters recalibrated for business tempo alignment."
        ],
        numHeads: [
          "Agent deployment strategy realigned with organizational priorities.",
          "Process thread count optimized for parallel execution capability.",
          "Resource distribution rebalanced across operational domains."
        ],
        waveFrequency: [
          "Business challenge periodicity recalibrated to match adaptive capacity.",
          "Strategic initiative deployment frequency adjusted to organizational readiness.",
          "Market disruption simulation interval modified for resilience testing."
        ],
        obstacleSize: [
          "Challenge complexity scaling factor adjusted to reflect current capability.",
          "Business impediment significance recalibrated for realistic response training.",
          "Problem domain boundary parameters modified for strategic assessment."
        ],
        obstacleSpeed: [
          "Market volatility simulation parameters adjusted to reflect current conditions.",
          "Business challenge velocity recalibrated for adaptive response training.",
          "Disruption propagation rate modified to test organizational agility."
        ],
        obstaclesPerWave: [
          "Challenge density modified to test organizational capacity.",
          "Concurrent problem threshold adjusted to reflect real-world conditions.",
          "Task multiplication factor recalibrated for resilience assessment."
        ]
      };
      
      // Initialize game
      function initGame() {
        // Initialize heads
        heads = [];
        for (let i = 0; i < numHeads; i++) {
          heads.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            dirX: (Math.random() * 2 - 1) * SPEED,
            dirY: (Math.random() * 2 - 1) * SPEED,
            trail: [{ x: canvas.width / 2, y: canvas.height / 2 }]
          });
        }
      }
      
      // Enhanced Particle class with more visual appeal
      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 5 + 2; // Larger particles
          this.speedX = (Math.random() * 2 - 1) * 3; // Faster movement
          this.speedY = (Math.random() * 2 - 1) * 3;
          // Colors as requested
          const colors = ['#FFE600', '#FFFFFF', '#808080'];
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.life = 60; // Longer life
          this.opacity = 1;
          this.initialSize = this.size;
        }
        
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.speedX *= 0.98; // Gradual slowdown
          this.speedY *= 0.98;
          this.life--;
          this.opacity = this.life / 60; // Fade out
          this.size = this.initialSize * (this.life / 60); // Shrink
        }
        
        draw() {
          ctx.globalAlpha = this.opacity;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Add glow effect
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
      }
      
      // Show tooltip
      function showTooltip(message, duration = 3000) {
        tooltip.textContent = message;
        tooltip.style.display = 'block';
        
        setTimeout(() => {
          tooltip.style.opacity = 0;
          setTimeout(() => {
            tooltip.style.display = 'none';
            tooltip.style.opacity = 1;
          }, 1000);
        }, duration);
      }
      
	  
	
		// Define process load threshold messages
		const processLoadMessages = {
		  threshold1: [
			"Process complexity is increasing - resource allocation optimization suggested.",
			"Initial complexity threshold reached - consider workflow streamlining measures.",
			"System load reaching first optimization threshold - review bottlenecks."
		  ],
		  threshold2: [
			"Process load at critical threshold - tactical intervention recommended.",
			"Workflow complexity requires additional oversight - escalation protocols activated.",
			"Mid-level complexity threshold breached - implementing adaptive measures."
		  ],
		  threshold3: [
			"Maximum process complexity approaching - strategic intervention required.",
			"System at high saturation - deploying advanced containment protocols.",
			"Critical process load detected - intelligent automation safeguards engaged."
		  ]
		};

		// Add these variables for threshold tracking
		let processLoadThresholds = {
		  threshold1: { value: PROCESS_LOAD_GOAL * 0.25, triggered: false },
		  threshold2: { value: PROCESS_LOAD_GOAL * 0.5, triggered: false },
		  threshold3: { value: PROCESS_LOAD_GOAL * 0.75, triggered: false }
		};

		// Then modify the updateProcessLoad function
		function updateProcessLoad(load) {
		  const percent = Math.min((load / PROCESS_LOAD_GOAL) * 100, 100);
		  complexityProgress.style.width = percent + '%';
		  complexityValueDisplay.textContent = Math.floor(load);
		  
		  // Check thresholds and show appropriate messages
		  checkProcessLoadThresholds(load);
		  
		  if (load >= PROCESS_LOAD_GOAL && !processLoadGoalReached) {
			processLoadGoalReached = true;
			overlayMessage.style.display = 'flex';
		  }
		}

		// Add this new function to check thresholds and display messages
		function checkProcessLoadThresholds(load) {
		  // Check each threshold in order
		  if (load >= processLoadThresholds.threshold3.value && !processLoadThresholds.threshold3.triggered) {
			showProcessLoadMessage('threshold3');
			processLoadThresholds.threshold3.triggered = true;
			
			// Visual indicator for high load
			complexityProgress.style.backgroundColor = '#FF4500'; // OrangeRed for critical
		  }
		  else if (load >= processLoadThresholds.threshold2.value && !processLoadThresholds.threshold2.triggered) {
			showProcessLoadMessage('threshold2');
			processLoadThresholds.threshold2.triggered = true;
			
			// Visual indicator for medium load
			complexityProgress.style.backgroundColor = '#FFA500'; // Orange for warning
		  }
		  else if (load >= processLoadThresholds.threshold1.value && !processLoadThresholds.threshold1.triggered) {
			showProcessLoadMessage('threshold1');
			processLoadThresholds.threshold1.triggered = true;
			
			// Visual indicator for initial load
			complexityProgress.style.backgroundColor = '#FFD700'; // Gold for notice
		  }
		}

		// Add this function to show the process load messages
		function showProcessLoadMessage(threshold) {
		  const messages = processLoadMessages[threshold];
		  const message = messages[Math.floor(Math.random() * messages.length)];
		  
		  // Clear any existing message timeout
		  if (messageTimeout) {
			clearTimeout(messageTimeout);
		  }
		  
		  // Use the businessMessage element to display the process load message
		  businessMessage.textContent = message;
		  businessMessage.style.opacity = 1;
		  
		  // Apply special styling for process load messages
		  businessMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
		  businessMessage.style.color = '#FFD700';
		  businessMessage.style.padding = '10px 15px';
		  businessMessage.style.borderLeft = '3px solid #FFD700';
		  
		  // Set timeout to fade out and restore styling
		  messageTimeout = setTimeout(() => {
			businessMessage.style.opacity = 0;
			setTimeout(() => {
			  // Reset styling after fade
			  businessMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
			  businessMessage.style.borderLeft = 'none';
			  businessMessage.style.padding = '5px 15px';
			}, 500);
		  }, 5000); // Show for 5 seconds
		  
		  // Also display as tooltip for additional visibility
		  showTooltip(message, 4000);
		}

		// Add this to the clear button event listener to reset thresholds
		clearButton.addEventListener('click', function() {
		  // ... existing code ...
		  
		  // Reset threshold triggers
		  processLoadThresholds.threshold1.triggered = false;
		  processLoadThresholds.threshold2.triggered = false;
		  processLoadThresholds.threshold3.triggered = false;
		  
		  // Reset progress bar color
		  complexityProgress.style.backgroundColor = '#FFD700';
		});

		// Same for the restart button
		restartButton.addEventListener('click', function() {
		  clearButton.click();
		  // The threshold resets will be handled by the clear button event
		});
	  
      // Show business message
      function showBusinessMessage(category) {
        if (!businessMessages[category]) return;
        
        const messages = businessMessages[category];
        const message = messages[Math.floor(Math.random() * messages.length)];
        
        // Clear any existing message timeout
        if (messageTimeout) {
          clearTimeout(messageTimeout);
        }
        
        // Display the message
        businessMessage.textContent = message;
        businessMessage.style.opacity = 1;
        
        // Set timeout to fade out
        messageTimeout = setTimeout(() => {
          businessMessage.style.opacity = 0;
        }, 3000);
      }
      
      // Create enhanced particles effect
      function createParticles(x, y) {
        for (let i = 0; i < 40; i++) { // More particles
          particles.push(new Particle(x, y));
        }
        isEffectActive = true;
      }
      
      // Change head direction
      function changeDirection(headIndex) {
        const head = heads[headIndex];
        const randomAngle = Math.random() * Math.PI * 2;
        head.dirX = Math.cos(randomAngle) * SPEED;
        head.dirY = Math.sin(randomAngle) * SPEED;
      }
      
      // Update wave countdown
		function updateWaveCountdown(deltaTime) {
		  waveCountdown -= deltaTime;
		  // Set the new countdown max each time the frequency changes
		  waveCountdownMax = 15000 / waveFrequencyFactor;
		  const percent = Math.max((waveCountdown / waveCountdownMax) * 100, 0);
		  waveCountdownProgress.style.width = percent + '%';
		  
		  if (waveCountdown <= 0) {
			triggerWave();
			waveCountdown = waveCountdownMax; // Reset countdown with new max value
		  }
		}
      
      // Trigger a new wave of obstacles
      function triggerWave() {
        // Always create at least a few obstacles, even on first wave
        const baseObstacles = Math.floor(5 * obstaclesRatio);
        const additionalObstacles = collisionCount < 4 ? 0 : Math.floor(collisionCount / 20);
        const numObstacles = baseObstacles + additionalObstacles;
        
        for (let i = 0; i < numObstacles; i++) {
          const size = customObstacleSize;
          const obstacle = {
            x: Math.random() * (canvas.width - size),
            y: Math.random() * (canvas.height - size),
            width: size,
            height: size,
            vx: (Math.random() * 2 - 1) * customObstacleSpeed,
            vy: (Math.random() * 2 - 1) * customObstacleSpeed
          };
          obstacles.push(obstacle);
        }
        showTooltip("New wave of strategic challenges emerging!");
      }
      
      // Update obstacles
      function updateObstacles() {
        obstacles.forEach(obs => {
          obs.x += obs.vx;
          obs.y += obs.vy;
          
          // Bounce off walls
          if (obs.x < 0 || obs.x + obs.width > canvas.width) {
            obs.vx = -obs.vx;
            obs.x = Math.max(0, Math.min(canvas.width - obs.width, obs.x));
          }
          if (obs.y < 0 || obs.y + obs.height > canvas.height) {
            obs.vy = -obs.vy;
            obs.y = Math.max(0, Math.min(canvas.height - obs.height, obs.y));
          }
        });
      }
      
      // Check head collisions
      function checkHeadCollisions() {
        for (let i = 0; i < heads.length - 1; i++) {
          for (let j = i + 1; j < heads.length; j++) {
            const dx = heads[i].x - heads[j].x;
            const dy = heads[i].y - heads[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < DOT_RADIUS * 2) {
              // Collision detected, change direction of both heads
              changeDirection(i);
              changeDirection(j);
              headCollisionCount++; // This doesn't affect process load
              createParticles((heads[i].x + heads[j].x) / 2, (heads[i].y + heads[j].y) / 2);
              showTooltip("Resource conflict detected - redirecting workflow.");
            }
          }
        }
      }
      
      // Draw game state
      function draw() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw static trails with gradient effect
        staticTrails.forEach(trail => {
          if (trail.length < 2) return;
          
          for (let i = 1; i < trail.length; i++) {
            // Calculate opacity based on position in trail - brighter at the end
            const opacity = i / trail.length;
            
            ctx.beginPath();
            ctx.moveTo(trail[i-1].x, trail[i-1].y);
            ctx.lineTo(trail[i].x, trail[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
          }
        });
        
        // Draw head trails with gradient effect - white at head, darker at the end
        heads.forEach(head => {
          if (head.trail.length < 2) return;
          
          for (let i = 1; i < head.trail.length; i++) {
            // Calculate opacity based on position in trail - brighter near head
            const opacity = (i / head.trail.length);
            
            ctx.beginPath();
            ctx.moveTo(head.trail[i-1].x, head.trail[i-1].y);
            ctx.lineTo(head.trail[i].x, head.trail[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
          }
        });
        
        // Draw obstacles as diamonds - original color
        obstacles.forEach(obstacle => {
          ctx.save();
          const centerX = obstacle.x + obstacle.width / 2;
          const centerY = obstacle.y + obstacle.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(Math.PI / 4);
          // Original gold color
          ctx.fillStyle = "#FF8C00";
          ctx.shadowBlur = 15;
          ctx.shadowColor = "#FF8C00";
          ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
          ctx.shadowBlur = 0;
          ctx.restore();
        });
        
        // Draw particles
        if (isEffectActive) {
          particles.forEach(particle => particle.draw());
        }
        
        // Draw heads
        heads.forEach(head => {
          ctx.beginPath();
          ctx.arc(head.x, head.y, DOT_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = '#ecd404';
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ecd404';
          ctx.fill();
          ctx.shadowBlur = 0;
        });
      }
      
      // Game loop
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }
      
      // Update process load - head collisions don't count
      function updateProcessLoad(load) {
        const percent = Math.min((load / PROCESS_LOAD_GOAL) * 100, 100);
        complexityProgress.style.width = percent + '%';
        complexityValueDisplay.textContent = Math.floor(load);
        
        if (load >= PROCESS_LOAD_GOAL && !processLoadGoalReached) {
          processLoadGoalReached = true;
          overlayMessage.style.display = 'flex';
        }
      }
      
      // Update game state
      function update() {
        // Update obstacles
        updateObstacles();
        
        // Update heads
        heads.forEach(head => {
          // Move the head
          head.x += head.dirX;
          head.y += head.dirY;
          
          // Bounce off walls
          if (head.x - DOT_RADIUS <= 0 || head.x + DOT_RADIUS >= canvas.width) {
            head.dirX = -head.dirX;
            head.x = Math.max(DOT_RADIUS, Math.min(canvas.width - DOT_RADIUS, head.x));
            collisionCount++;
          }
          if (head.y - DOT_RADIUS <= 0 || head.y + DOT_RADIUS >= canvas.height) {
            head.dirY = -head.dirY;
            head.y = Math.max(DOT_RADIUS, Math.min(canvas.height - DOT_RADIUS, head.y));
            collisionCount++;
          }
          
          // Check collisions with obstacles
          obstacles.forEach(obstacle => {
            if (head.x + DOT_RADIUS > obstacle.x && head.x - DOT_RADIUS < obstacle.x + obstacle.width &&
                head.y + DOT_RADIUS > obstacle.y && head.y - DOT_RADIUS < obstacle.y + obstacle.height) {
              // Collision detected
              const angle = Math.atan2(head.y - (obstacle.y + obstacle.height/2), 
                                     head.x - (obstacle.x + obstacle.width/2));
              head.dirX = Math.cos(angle) * SPEED;
              head.dirY = Math.sin(angle) * SPEED;
              collisionCount++;
              
              // Always create particles on obstacle collision
              createParticles(head.x, head.y);
            }
          });
          
          // Update trail
          head.trail.push({x: head.x, y: head.y});
          if (head.trail.length > MAX_TRAIL_LENGTH) {
            head.trail.shift();
          }
        });
        
        // Check head collisions
        checkHeadCollisions();
        
        // Update particles
        if (isEffectActive) {
          for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) {
              particles.splice(i, 1);
            }
          }
          if (particles.length === 0) {
            isEffectActive = false;
          }
        }
        
        // Update process load (based only on obstacle collisions, not head collisions)
        const processLoad = collisionCount * 50;
        updateProcessLoad(processLoad);
        
        // Update collisions display
        collisionsValue.textContent = collisionCount;
        
        // Update wave countdown
        const now = performance.now();
        const deltaTime = now - lastFrameTime;
        lastFrameTime = now;
        updateWaveCountdown(deltaTime);
      }
      
      // Event listeners
      
      // Container size slider
      containerSizeSlider.addEventListener('input', function() {
        const size = parseInt(this.value);
        containerSizeValue.textContent = size + 'px';
        
        // Only update container size on mouseup/touchend to prevent page jumping
        showBusinessMessage('containerSize');
      });
      
      // Apply container size changes only when sliding is complete
      containerSizeSlider.addEventListener('change', function() {
        const size = parseInt(this.value);
        mazeContainer.style.width = size + 'px';
        mazeContainer.style.height = size + 'px';
        
        // Update canvas size
        canvas.width = size;
        canvas.height = size;
        
        // Ensure heads stay within bounds
        heads.forEach(head => {
          head.x = Math.min(head.x, canvas.width - DOT_RADIUS);
          head.y = Math.min(head.y, canvas.height - DOT_RADIUS);
        });
      });
      
      // Head size slider
      headSizeSlider.addEventListener('input', function() {
        DOT_RADIUS = parseFloat(this.value);
        headSizeValue.textContent = DOT_RADIUS + 'px';
        showBusinessMessage('headSize');
      });
      
      // Trail Length slider
      trailLengthSlider.addEventListener('input', function() {
        MAX_TRAIL_LENGTH = parseInt(this.value);
        trailLengthValue.textContent = MAX_TRAIL_LENGTH;
        
        // Trim existing trails if needed
        heads.forEach(head => {
          if (head.trail.length > MAX_TRAIL_LENGTH) {
            head.trail = head.trail.slice(head.trail.length - MAX_TRAIL_LENGTH);
          }
        });
        
        staticTrails.forEach((trail, index) => {
          if (trail.length > MAX_TRAIL_LENGTH) {
            staticTrails[index] = trail.slice(trail.length - MAX_TRAIL_LENGTH);
          }
        });
        
        showBusinessMessage('trailLength');
      });
      
      // Speed slider
      speedSlider.addEventListener('input', function() {
        SPEED = parseFloat(this.value);
        speedValue.textContent = SPEED;
        
        // Update head speeds
        heads.forEach(head => {
          const angle = Math.atan2(head.dirY, head.dirX);
          head.dirX = Math.cos(angle) * SPEED;
          head.dirY = Math.sin(angle) * SPEED;
        });
        
        showBusinessMessage('speed');
      });
      
      // Number of heads slider
      numHeadsSlider.addEventListener('input', function() {
        const newNumHeads = parseInt(this.value);
        numHeadsValue.textContent = newNumHeads;
        
        // Add or remove heads as needed
        while (heads.length < newNumHeads) {
          heads.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            dirX: (Math.random() * 2 - 1) * SPEED,
            dirY: (Math.random() * 2 - 1) * SPEED,
            trail: [{ x: canvas.width / 2, y: canvas.height / 2 }]
          });
        }
        
        while (heads.length > newNumHeads) {
          const removed = heads.pop();
          staticTrails.push(removed.trail);
        }
        
        showBusinessMessage('numHeads');
      });
      
      // Wave frequency slider
		waveFrequencySlider.addEventListener('input', function() {
		  waveFrequencyFactor = parseFloat(this.value);
		  waveFrequencyValue.textContent = waveFrequencyFactor.toFixed(1);
		  // Update the waveCountdownMax
		  waveCountdownMax = 15000 / waveFrequencyFactor;
		  // Reset the current countdown to match the new max (maintain the same percentage)
		  const currentPercent = waveCountdown / (15000 / (waveFrequencyFactor - (this.value - this.oldValue)));
		  waveCountdown = currentPercent * waveCountdownMax;
		  
		  showBusinessMessage('waveFrequency');
		});
		// Add an event listener to track the old value
		waveFrequencySlider.addEventListener('mousedown', function() {
		  this.oldValue = parseFloat(this.value);
		});
		waveFrequencySlider.addEventListener('touchstart', function() {
		  this.oldValue = parseFloat(this.value);
		});
      
      // Obstacle size slider
      obstacleSizeSlider.addEventListener('input', function() {
        customObstacleSize = parseInt(this.value);
        obstacleSizeValue.textContent = customObstacleSize + 'px';
        
        // Update existing obstacles
        obstacles.forEach(obs => {
          obs.width = customObstacleSize;
          obs.height = customObstacleSize;
        });
        
        showBusinessMessage('obstacleSize');
      });
      
      // Obstacle speed slider
      obstacleSpeedSlider.addEventListener('input', function() {
        customObstacleSpeed = parseFloat(this.value);
        obstacleSpeedValue.textContent = customObstacleSpeed.toFixed(1);
        
        // Update existing obstacles
        obstacles.forEach(obs => {
          obs.vx = Math.sign(obs.vx) * customObstacleSpeed;
          obs.vy = Math.sign(obs.vy) * customObstacleSpeed;
        });
        
        showBusinessMessage('obstacleSpeed');
      });
      
      // Obstacles per wave ratio slider
      obstaclesPerWaveSlider.addEventListener('input', function() {
        obstaclesRatio = parseFloat(this.value);
        obstaclesPerWaveValue.textContent = obstaclesRatio.toFixed(1);
        
        showBusinessMessage('obstaclesPerWave');
      });
      
      // Clear button
      clearButton.addEventListener('click', function() {
        heads.forEach(head => {
          head.trail = [{ x: head.x, y: head.y }];
        });
        staticTrails = [];
        obstacles = [];
        collisionCount = 0;
        headCollisionCount = 0;
        waveCountdown = waveCountdownMax;
        updateProcessLoad(0);
        processLoadGoalReached = false;
        overlayMessage.style.display = 'none';
        
        showBusinessMessage('containerSize'); // Show a reset message
      });
      
      // Restart button
      restartButton.addEventListener('click', function() {
        clearButton.click();
      });
      
      // Canvas click
      canvas.addEventListener('click', function(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        // Check if clicked on a head or near it (improved hit detection)
        for (let i = 0; i < heads.length; i++) {
          const head = heads[i];
          const distance = Math.sqrt(Math.pow(mouseX - head.x, 2) + Math.pow(mouseY - head.y, 2));
          // Increased detection radius for better usability
          if (distance <= DOT_RADIUS * 1.5) {
            changeDirection(i);
            createParticles(head.x, head.y);
            showTooltip("Direction changed - strategic pivot initiated.");
            return;
          }
        }
        
        // Check if clicked on an obstacle - more lenient detection
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          const centerX = obs.x + obs.width / 2;
          const centerY = obs.y + obs.height / 2;
          
          // More generous hit detection for obstacles (square-based)
          if (mouseX >= obs.x - 10 && mouseX <= obs.x + obs.width + 10 &&
              mouseY >= obs.y - 10 && mouseY <= obs.y + obs.height + 10) {
            createParticles(centerX, centerY);
            obstacles.splice(i, 1);
            showTooltip("Obstacle neutralized - path cleared.");
            return;
          }
        }
        
        // Create particles on click even if not hitting anything specific
        createParticles(mouseX, mouseY);
      });
      
      // Make sure business messages show on all slider changes
      const allSliders = document.querySelectorAll('.slider');
      allSliders.forEach(slider => {
        slider.addEventListener('change', function() {
          // Get the control group parent to determine which slider was moved
          const controlGroup = this.closest('.control-group');
          const controlLabel = controlGroup.querySelector('.control-label span:first-child').textContent.trim().toLowerCase();
          
          // Map the label to a category in the business messages object
          let category;
          if (controlLabel.includes('container size')) category = 'containerSize';
          else if (controlLabel.includes('head size')) category = 'headSize';
          else if (controlLabel.includes('trail length')) category = 'trailLength';
          else if (controlLabel.includes('speed')) category = 'speed';
          else if (controlLabel.includes('number of heads')) category = 'numHeads';
          else if (controlLabel.includes('wave frequency')) category = 'waveFrequency';
          else if (controlLabel.includes('obstacle size')) category = 'obstacleSize';
          else if (controlLabel.includes('obstacle speed')) category = 'obstacleSpeed';
          else if (controlLabel.includes('obstacles per wave')) category = 'obstaclesPerWave';
          
          if (category) {
            showBusinessMessage(category);
          }
        });
      });
      
      // Initialize and start the game loop
      initGame();
      gameLoop();
      
      // Show initial business message
      showBusinessMessage('containerSize');
      
      // Initialize controls state 
      const controlsContainer = document.querySelector('.controls-container');
      controlsContainer.style.display = 'none'; // Start with controls hidden
      
      // Make subsections expanded by default
      sectionHeaders.forEach(header => {
        if (!header.classList.contains('main-controls-header')) {
          const content = header.nextElementSibling;
          const icon = header.querySelector('.collapse-icon');
          content.classList.remove('collapsed');
          icon.classList.remove('collapsed');
        } else {
          const icon = header.querySelector('.collapse-icon');
          icon.classList.add('collapsed');
        }
      });
    });
  </script>
  
  <!-- ElevenLabs Convai Widget Script -->
  <script src="https://elevenlabs.io/convai-widget/index.js" type="text/javascript"></script>
</body>
</html>