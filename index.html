<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDS Intelligent Automation Team</title>
  <style>
    /* Main site styling */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .logo {
      display: flex;
      align-items: center;
      font-size: 1.5rem;
      color: #fff;
    }
    
    .logo-image {
      height: 40px;
      margin-right: 10px;
    }
    
    nav ul {
      display: flex;
      list-style: none;
      padding: 0;
    }
    
    nav ul li {
      margin-left: 20px;
    }
    
    nav ul li a {
      color: #fff;
      text-decoration: none;
    }
    
    .hero {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      padding: 60px 0;
      align-items: center;
    }
    
    .hero-content h1 {
      font-size: 2.5rem;
      line-height: 1.2;
    }
    
    .highlight {
      color: #FFD700;
    }
    
    .hero-image img {
      width: 100%;
      border-radius: 8px;
    }
    
    .services {
      padding: 40px 0;
    }
    
    .maze-title {
      font-size: 2rem;
      color: #FFD700;
      text-align: center;
      margin-bottom: 10px;
    }
    
    .maze-description {
      text-align: center;
      max-width: 800px;
      margin: 0 auto 40px;
    }
    
    .convai-wrapper {
      margin-top: 60px;
    }
    
    /* Game styles */
    .game-control-wrapper {
      display: grid;
      grid-template-columns: auto 1fr;
      grid-template-areas: 
        "maze controls"
        "process process";
      gap: 20px;
      margin: 20px auto;
      overflow: hidden; /* Prevent jumping during resize */
    }
    
    #mazeContainer {
      grid-area: maze;
      width: 530px;
      height: 570px;
      background-color: #000;
      position: relative;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      border: none;
      overflow: hidden;
      transition: width 0.3s ease, height 0.3s ease; /* Smooth transition */
    }
    
    .controls-wrapper {
      grid-area: controls;
    }
    
    .controls-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 15px;
    }
    
    .advanced-controls, .standard-controls, .process-load-container {
      background-color: #222;
      border: none;
      padding: 15px;
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding-bottom: 8px;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .section-header h3 {
      margin: 0;
      color: #FFD700;
      font-size: 1.2rem;
    }
    
    .main-controls-header {
      background-color: #222;
      border-radius: 4px;
      padding: 10px 15px;
      margin-bottom: 0;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      cursor: pointer;
    }
    
    .collapse-icon {
      color: #FFD700;
      transition: transform 0.3s ease;
    }
    
    .collapse-icon.collapsed {
      transform: rotate(-90deg);
    }
    
    .section-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: 500px;
      padding: 0 5px;
    }
    
    .section-content.collapsed {
      max-height: 0;
    }
    
    h3 {
      color: #FFD700;
      margin-top: 0;
    }
    
    .control-group {
      margin-bottom: 20px;
    }
    
    .control-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      color: #FFD700;
    }
    
    .control-value {
      color: white;
    }
    
    .slider {
      width: 100%;
      height: 5px;
      -webkit-appearance: none;
      background: #333;
      outline: none;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid #FFD700;
      margin: 8px 0;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: #FFD700;
      cursor: pointer;
    }
    
    .process-load-container {
      grid-area: process;
      margin-top: 20px;
    }
    
    .progress-bar, .wave-progress-bar {
      width: 100%;
      background: #333;
      height: 10px;
      border-radius: 5px;
      overflow: hidden;
      border: 1px solid #FFD700;
    }
    
    .progress, .wave-progress {
      height: 100%;
      background: #FFD700;
      width: 0%;
      transition: width 0.3s;
    }
    
    .wave-progress {
      width: 100%;
    }
    
    #clearButton, #restartButton {
      background-color: #FFD700;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
    }
    
    #tooltip {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #FFD700;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 0.9rem;
      opacity: 1;
      display: none;
      z-index: 50;
    }
    
    /* Business message style */
    .business-message {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      text-align: center;
      color: #FFD700;
      font-size: 1rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 15px;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
    }
    
    #overlayMessage {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #FFD700;
      font-size: 1.8rem;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    
    /* Media query for mobile screens */
    @media (max-width: 1024px) {
      .game-control-wrapper {
        grid-template-columns: 1fr;
        grid-template-areas: 
          "maze"
          "controls"
          "process";
      }
      
      #mazeContainer {
        width: 100%;
        height: 500px;
        max-width: 500px;
        margin: 0 auto;
      }
      
      .controls-container {
        grid-template-columns: 1fr;
      }
      
      .hero {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 768px) {
      .game-control-wrapper {
        grid-template-columns: 1fr;
      }
      
      .controls-container {
        grid-template-columns: 1fr;
      }
      
      #mazeContainer {
        width: 100%;
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <img src="LogoIA.png" alt="Logo" class="logo-image">
        GDS Intelligent Automation Team
      </div>
      <nav>
        <ul>
          <li><a href="#">Home</a></li>
          <li><a href="#">What Do We Do</a></li>
          <li><a href="#">Case Studies</a></li>
          <li><a href="#">Contact</a></li>
        </ul>
      </nav>
    </header>
    
    <section class="hero">
      <div class="hero-content">
        <h1>Transform your business with <span class="highlight">Intelligent Automation</span>: Efficiency, Innovation, and Growth at your fingertips</h1>
      </div>
      <div class="hero-image">
        <img src="lines.jpg" alt="Circuit Lines" />
      </div>
    </section>
    
    <section class="services">
      
      <!-- Maze Game Section -->
      <h3 class="maze-title">Intelligent Automation Pathfinder</h3>
      <p class="maze-description">Explore how automated processes navigate through complex business challenges. Click on the moving dot(s) to change their direction, neutralize obstacles with a click, and observe how they create evolving process pathways. Adjust controls to optimize performance and manage strategic challenges through the system.</p>
      
      <!-- Game Control Wrapper -->
      <div class="game-control-wrapper">
        <div id="mazeContainer">
          <div id="tooltip"></div>
          <div class="business-message" id="businessMessage"></div>
          <div id="overlayMessage">
            Discover how our Intelligent Automation department can guide you through the maze of technology and process complexity. Use our voice bot to contact us and start your journey to streamlined innovation!
            <button id="restartButton">Start Your Jurney Again</button>
          </div>
        </div>
        
        <div class="controls-wrapper">
          <div class="section-header main-controls-header">
            <h3>Controls Panel</h3>
            <span class="collapse-icon">▼</span>
          </div>
          <div class="controls-container">
            <!-- Standard Controls -->
            <div class="standard-controls">
              <div class="section-header">
                <h3>Standard Controls</h3>
                <span class="collapse-icon">▼</span>
              </div>
              <div class="section-content">
                <div class="control-group">
                  <div class="control-label">
                    <span>Workspace Capacity</span>
                    <span class="control-value" id="containerSizeValue">570px</span>
                  </div>
                  <input type="range" min="450" max="800" value="570" class="slider" id="containerSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Decision Point Scale</span>
                    <span class="control-value" id="headSizeValue">7.5px</span>
                  </div>
                  <input type="range" min="3" max="20" value="7.5" step="0.5" class="slider" id="headSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Process Memory</span>
                    <span class="control-value" id="trailLengthValue">2000</span>
                  </div>
                  <input type="range" min="1000" max="8000" value="2000" step="100" class="slider" id="trailLengthSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Execution Rate</span>
                    <span class="control-value" id="speedValue">2</span>
                  </div>
                  <input type="range" min="0.5" max="8" value="2" step="0.5" class="slider" id="speedSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Parallel Operations</span>
                    <span class="control-value" id="numHeadsValue">1</span>
                  </div>
                  <input type="range" min="1" max="3" value="1" step="1" class="slider" id="numHeadsSlider">
                </div>
                <button id="clearButton">Clear Maze</button>
              </div>
            </div>
            
            <!-- Advanced Controls: Business Parameters -->
            <div class="advanced-controls">
              <div class="section-header">
                <h3>Business Parameters</h3>
                <span class="collapse-icon">▼</span>
              </div>
              <div class="section-content">
                <div class="control-group">
                  <div class="control-label">
                    <span>Market Cycle Rate</span>
                    <span class="control-value" id="waveFrequencyValue">1.0</span>
                  </div>
                  <input type="range" min="0.5" max="2" value="1" step="0.1" class="slider" id="waveFrequencySlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Challenge Magnitude</span>
                    <span class="control-value" id="obstacleSizeValue">40px</span>
                  </div>
                  <input type="range" min="20" max="80" value="40" class="slider" id="obstacleSizeSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Disruption Velocity</span>
                    <span class="control-value" id="obstacleSpeedValue">1.0</span>
                  </div>
                  <input type="range" min="0.5" max="3.0" value="1.0" step="0.1" class="slider" id="obstacleSpeedSlider">
                </div>
                <div class="control-group">
                  <div class="control-label">
                    <span>Risk Density Factor</span>
                    <span class="control-value" id="obstaclesPerWaveValue">1.0</span>
                  </div>
                  <input type="range" min="0.5" max="2.0" value="1.0" step="0.1" class="slider" id="obstaclesPerWaveSlider">
                </div>
                <div class="wave-countdown-container">
                  <div class="control-label">
                    <span>Innovation Pipeline Timer</span>
                  </div>
                  <div class="wave-progress-bar">
                    <div class="wave-progress" id="waveCountdownProgress"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Process Load Tracker -->
        <div class="process-load-container">
          <div class="section-header">
            <h3>Process Load</h3>
            <span class="collapse-icon">▼</span>
          </div>
          <div class="section-content">
            <div class="control-label">
              <span>Process Load</span>
              <span class="control-value" id="complexityValueDisplay">0</span>
            </div>
            <div class="progress-bar">
              <div class="progress" id="complexityProgress"></div>
            </div>
            <div class="control-label">
              <span>Collisions</span>
              <span class="control-value" id="collisionsValue">0</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- ElevenLabs Convai Widget Container -->
      <div class="convai-wrapper">
        <elevenlabs-convai agent-id="GzXUUK45tH3zF6kwllQH"></elevenlabs-convai>
      </div>
    </section>
  </div>
  
<script>
    document.addEventListener('DOMContentLoaded', function() {
      // Basic setup
      const mazeContainer = document.getElementById('mazeContainer');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size to match container
      canvas.width = mazeContainer.clientWidth;
      canvas.height = mazeContainer.clientHeight;
      mazeContainer.appendChild(canvas);
      
      // UI elements
      const containerSizeSlider = document.getElementById('containerSizeSlider');
      const headSizeSlider = document.getElementById('headSizeSlider');
      const trailLengthSlider = document.getElementById('trailLengthSlider');
      const speedSlider = document.getElementById('speedSlider');
      const numHeadsSlider = document.getElementById('numHeadsSlider');
      const waveFrequencySlider = document.getElementById('waveFrequencySlider');
      const obstacleSizeSlider = document.getElementById('obstacleSizeSlider');
      const obstacleSpeedSlider = document.getElementById('obstacleSpeedSlider');
      const obstaclesPerWaveSlider = document.getElementById('obstaclesPerWaveSlider');
      const waveCountdownProgress = document.getElementById('waveCountdownProgress');
      const clearButton = document.getElementById('clearButton');
      const restartButton = document.getElementById('restartButton');
      const tooltip = document.getElementById('tooltip');
      const businessMessage = document.getElementById('businessMessage');
      const overlayMessage = document.getElementById('overlayMessage');
      const sectionHeaders = document.querySelectorAll('.section-header');
      
      // Display elements
      const containerSizeValue = document.getElementById('containerSizeValue');
      const headSizeValue = document.getElementById('headSizeValue');
      const trailLengthValue = document.getElementById('trailLengthValue');
      const speedValue = document.getElementById('speedValue');
      const numHeadsValue = document.getElementById('numHeadsValue');
      const waveFrequencyValue = document.getElementById('waveFrequencyValue');
      const obstacleSizeValue = document.getElementById('obstacleSizeValue');
      const obstacleSpeedValue = document.getElementById('obstacleSpeedValue');
      const obstaclesPerWaveValue = document.getElementById('obstaclesPerWaveValue');
      const complexityProgress = document.getElementById('complexityProgress');
      const complexityValueDisplay = document.getElementById('complexityValueDisplay');
      const collisionsValue = document.getElementById('collisionsValue');
      
      // Game parameters
      let DOT_RADIUS = parseFloat(headSizeSlider.value);
      let MAX_TRAIL_LENGTH = parseInt(trailLengthSlider.value);
      let SPEED = parseFloat(speedSlider.value);
      let numHeads = parseInt(numHeadsSlider.value);
      let waveFrequencyFactor = parseFloat(waveFrequencySlider.value);
      let customObstacleSize = parseInt(obstacleSizeSlider.value);
      let customObstacleSpeed = parseFloat(obstacleSpeedSlider.value);
      let obstaclesRatio = parseFloat(obstaclesPerWaveSlider.value);
      const LINE_WIDTH = 2;
      
      // Game state
      let heads = [];
      let obstacles = [];
      let staticTrails = [];
      let particles = [];
      let isEffectActive = false;
      let collisionCount = 0;
      let headCollisionCount = 0; // Separate counter for head collisions
      let wallCollisionCount = 0; // Track wall collisions separately
      let headObstacleCollisions = new Set(); // To track which heads have collided with which obstacles
      let lastFrameTime = performance.now();
      let waveCountdownMax = 15000 / waveFrequencyFactor;
      let waveCountdown = waveCountdownMax;
      let messageTimeout = null;
      let controlsVisible = false;
      let isGameFrozen = false; // Add game freeze state variable
      
      // Constants
      const PROCESS_LOAD_GOAL = 2000;
      let processLoadGoalReached = false;
      
      // Set up collapsible sections
      sectionHeaders.forEach(header => {
        if (header.classList.contains('main-controls-header')) {
          // Special handling for main controls header
          header.addEventListener('click', function() {
            const controlsContainer = document.querySelector('.controls-container');
            const icon = this.querySelector('.collapse-icon');
            
            if (controlsContainer.style.display === 'none' || controlsContainer.style.display === '') {
              controlsContainer.style.display = 'grid';
              icon.classList.remove('collapsed');
              controlsVisible = true;
            } else {
              controlsContainer.style.display = 'none';
              icon.classList.add('collapsed');
              controlsVisible = false;
            }
          });
        } else {
          // Regular section headers
          header.addEventListener('click', function() {
            const content = this.nextElementSibling;
            const icon = this.querySelector('.collapse-icon');
            
            if (content.classList.contains('collapsed')) {
              content.classList.remove('collapsed');
              icon.classList.remove('collapsed');
            } else {
              content.classList.add('collapsed');
              icon.classList.add('collapsed');
            }
          });
        }
      });
      
      // Enhanced Business Messages - organized by slider category and value range
      const businessMessages = {
        containerSize: {
          low: "Infrastructure scaled down to enhance focus on core operations.",
          medium: "Workspace capacity optimized for current operational requirements.",
          high: "Infrastructure expanded to accommodate growing business complexity.",
          increasing: "Digital workspace capacity increasing to support expanded operations.",
          decreasing: "Platform footprint being streamlined for improved performance."
        },
        headSize: {
          low: "Decision point granularity refined for precise process execution.",
          medium: "Agent interaction radius balanced for optimal engagement.",
          high: "Resource allocation points expanded for comprehensive task coverage.",
          increasing: "Increasing decision point impact radius for broader operational influence.",
          decreasing: "Refining execution precision with more targeted decision points."
        },
        trailLength: {
          low: "Process history retention minimized for agile performance.",
          medium: "Workflow trace depth balanced for operational analytics.",
          high: "Extended process memory implemented for comprehensive audit capability.",
          increasing: "Extending process memory capacity for enhanced historical analysis.",
          decreasing: "Optimizing memory footprint for improved processing efficiency."
        },
        speed: {
          low: "Process execution cadence reduced for deliberate, careful progression.",
          medium: "Operational velocity calibrated for balanced throughput.",
          high: "Execution rate maximized for accelerated business outcomes.",
          increasing: "Accelerating operational tempo to meet market demands.",
          decreasing: "Moderating execution velocity for improved quality assurance."
        },
        numHeads: {
          low: "Single-threaded process execution for focused workflow management.",
          medium: "Dual-track operations enabled for parallel process handling.",
          high: "Multi-threaded execution deployed for maximum concurrent operations.",
          increasing: "Scaling up parallel operations for enhanced throughput capacity.",
          decreasing: "Consolidating operational threads for improved resource utilization."
        },
        waveFrequency: {
          low: "Market cycle intervals extended for strategic adaptation planning.",
          medium: "Business challenge frequency balanced for optimal response preparation.",
          high: "Rapid market cycle simulation for advanced business agility training.",
          increasing: "Accelerating disruption cycles to test organizational responsiveness.",
          decreasing: "Extending market cycle intervals for deeper strategic planning."
        },
        obstacleSize: {
          low: "Minor business challenges deployed for baseline resilience development.",
          medium: "Standard market obstacles presented for balanced adaptation training.",
          high: "Major disruption scenarios activated for advanced contingency planning.",
          increasing: "Scaling up challenge complexity to stress-test organizational capabilities.",
          decreasing: "Reducing obstacle magnitude to focus on fundamental response techniques."
        },
        obstacleSpeed: {
          low: "Deliberate market evolution pace for measured response development.",
          medium: "Standard volatility conditions for balanced adaptation training.",
          high: "Rapid-change business environment for advanced agility development.",
          increasing: "Accelerating disruption velocity to enhance rapid response capabilities.",
          decreasing: "Moderating challenge propagation for strategic response refinement."
        },
        obstaclesPerWave: {
          low: "Focused disruption strategy with limited concurrent challenges.",
          medium: "Balanced challenge portfolio for holistic resilience development.",
          high: "High-density problem environment for advanced capacity building.",
          increasing: "Intensifying concurrent challenge density to test organizational capacity.",
          decreasing: "Reducing simultaneous disruptions to enable focused problem-solving."
        },
        process: {
          threshold1: "Process complexity is increasing - resource allocation optimization suggested.",
          threshold2: "Process load at critical threshold - tactical intervention recommended.",
          threshold3: "Maximum process complexity approaching - strategic intervention required."
        }
      };
      
      // Helper function to get slider ranges for percentage calculation
      function getSliderRanges(category) {
        // Default ranges
        const ranges = {
          containerSize: { min: 450, max: 800 },
          headSize: { min: 3, max: 20 },
          trailLength: { min: 1000, max: 8000 },
          speed: { min: 0.5, max: 8 },
          numHeads: { min: 1, max: 3 },
          waveFrequency: { min: 0.5, max: 2 },
          obstacleSize: { min: 20, max: 80 },
          obstacleSpeed: { min: 0.5, max: 3.0 },
          obstaclesPerWave: { min: 0.5, max: 2.0 }
        };
        
        return ranges[category];
      }
      
      // Helper function to get slider element by category
      function getSliderByCategory(category) {
        const sliderMap = {
          containerSize: document.getElementById('containerSizeSlider'),
          headSize: document.getElementById('headSizeSlider'),
          trailLength: document.getElementById('trailLengthSlider'),
          speed: document.getElementById('speedSlider'),
          numHeads: document.getElementById('numHeadsSlider'),
          waveFrequency: document.getElementById('waveFrequencySlider'),
          obstacleSize: document.getElementById('obstacleSizeSlider'),
          obstacleSpeed: document.getElementById('obstacleSpeedSlider'),
          obstaclesPerWave: document.getElementById('obstaclesPerWaveSlider')
        };
        
        return sliderMap[category];
      }
      
      // Function to determine message based on slider value and previous value
      function getSmartBusinessMessage(category, value, oldValue) {
        // Default to medium if no old value is available
        if (oldValue === undefined) oldValue = value;
        
        // Get the range for the slider category
        const ranges = getSliderRanges(category);
        
        // Determine message type based on value and direction of change
        let messageType;
        
        // First determine the direction of change
        if (value > oldValue) {
          messageType = "increasing";
        } else if (value < oldValue) {
          messageType = "decreasing";
        } else {
          // If no change or first time, determine based on where in the range it falls
          const percentage = (value - ranges.min) / (ranges.max - ranges.min);
          
          if (percentage < 0.33) {
            messageType = "low";
          } else if (percentage < 0.66) {
            messageType = "medium";
          } else {
            messageType = "high";
          }
        }
        
        return businessMessages[category][messageType];
      }
      
      // Initialize game
      function initGame() {
        // Initialize heads
        heads = [];
        for (let i = 0; i < numHeads; i++) {
          heads.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            dirX: (Math.random() * 2 - 1) * SPEED,
            dirY: (Math.random() * 2 - 1) * SPEED,
            trail: [{ x: canvas.width / 2, y: canvas.height / 2 }]
          });
        }
      }
      
      // Enhanced Particle class with more visual appeal
      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 5 + 2; // Larger particles
          this.speedX = (Math.random() * 2 - 1) * 3; // Faster movement
          this.speedY = (Math.random() * 2 - 1) * 3;
          // Colors as requested
          const colors = ['#FFE600', '#FFFFFF', '#808080'];
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.life = 60; // Longer life
          this.opacity = 1;
          this.initialSize = this.size;
        }
        
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.speedX *= 0.98; // Gradual slowdown
          this.speedY *= 0.98;
          this.life--;
          this.opacity = this.life / 60; // Fade out
          this.size = this.initialSize * (this.life / 60); // Shrink
        }
        
        draw() {
          ctx.globalAlpha = this.opacity;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Add glow effect
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
      }
      
      // Show tooltip
      function showTooltip(message, duration = 3000) {
        tooltip.textContent = message;
        tooltip.style.display = 'block';
        
        setTimeout(() => {
          tooltip.style.opacity = 0;
          setTimeout(() => {
            tooltip.style.display = 'none';
            tooltip.style.opacity = 1;
          }, 1000);
        }, duration);
      }
      
      // Add these variables for threshold tracking
      let processLoadThresholds = {
        threshold1: { value: PROCESS_LOAD_GOAL * 0.25, triggered: false },
        threshold2: { value: PROCESS_LOAD_GOAL * 0.5, triggered: false },
        threshold3: { value: PROCESS_LOAD_GOAL * 0.75, triggered: false }
      };
      
      // Function to show a message about the game freeze
      function showFreezeMessage() {
        // Clear any existing message timeout
        if (messageTimeout) {
          clearTimeout(messageTimeout);
        }
        
        // Display a persistent message about the freeze
        const freezeMsg = "Process load critical threshold reached (300 collisions). System paused to prevent browser overload.";
        businessMessage.textContent = freezeMsg;
        businessMessage.style.opacity = 1;
        
        // Style the message to make it more noticeable
        businessMessage.style.backgroundColor = 'rgba(220, 20, 20, 0.8)'; // Reddish background
        businessMessage.style.color = 'white';
        businessMessage.style.padding = '10px 15px';
        businessMessage.style.fontWeight = 'bold';
        businessMessage.style.borderLeft = '3px solid #FFFFFF';
        
        // Don't set a timeout - message stays until user takes action
        
        // Also show a tooltip that will fade away
        showTooltip("System frozen: Press 'Clear Maze' to reset and continue.", 8000);
      }
      
      // Function to create a visual freeze effect
      function createFreezeEffect() {
        // Create a frost/freeze overlay effect
        const freezeOverlay = document.createElement('div');
        freezeOverlay.id = 'freezeOverlay';
        freezeOverlay.style.position = 'absolute';
        freezeOverlay.style.top = '0';
        freezeOverlay.style.left = '0';
        freezeOverlay.style.width = '100%';
        freezeOverlay.style.height = '100%';
        freezeOverlay.style.backgroundColor = 'rgba(100, 149, 237, 0.2)'; // Light blue tint
        freezeOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through
        freezeOverlay.style.zIndex = '10';
        
        // Add a subtle frost-like pattern
        freezeOverlay.style.backgroundImage = 'radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px)';
        freezeOverlay.style.backgroundSize = '10px 10px';
        
        // Add to the maze container
        mazeContainer.appendChild(freezeOverlay);
      }
      
      // Function to freeze the game
      function freezeGame() {
        isGameFrozen = true;
        
        // Display a notification about the freeze
        showFreezeMessage();
        
        // Create a visual freeze effect
        createFreezeEffect();
      }
      
      // Modified showBusinessMessage for smart message selection
      function showBusinessMessage(category, value, oldValue, specificMessage = null) {
        // Clear any existing message timeout
        if (messageTimeout) {
          clearTimeout(messageTimeout);
        }
        
        // Use the specific message if provided
        let message = specificMessage;
        
        // If no specific message, generate one based on category and values
        if (!message) {
          if (value !== undefined && category in businessMessages) {
            message = getSmartBusinessMessage(category, value, oldValue);
          } else if (category in businessMessages) {
            // If no value provided, get a message based on current slider value
            const slider = getSliderByCategory(category);
            if (slider) {
              const currentValue = parseFloat(slider.value);
              message = getSmartBusinessMessage(category, currentValue);
            } else if (category === 'process') {
              // Process messages have separate structure
              message = businessMessages.process.threshold1;
            } else {
              // Fallback to a message from the category
              const messageTypes = Object.keys(businessMessages[category]);
              const randomType = messageTypes[Math.floor(Math.random() * messageTypes.length)];
              message = businessMessages[category][randomType];
            }
          } else {
            message = "Process status updated.";
          }
        }
        
        // Display the message
        businessMessage.textContent = message;
        businessMessage.style.opacity = 1;
        
        // Set timeout to fade out after 3 seconds (unless this is a freeze message)
        if (!isGameFrozen) {
          messageTimeout = setTimeout(() => {
            businessMessage.style.opacity = 0;
          }, 3000);
        }
      }
      
      // Then modify the updateProcessLoad function
      function updateProcessLoad(load) {
        // Limit the load to the equivalent of 300 collisions (15000)
        const cappedLoad = Math.min(load, 15000);
        
        // Update the progress bar
        const percent = Math.min((cappedLoad / PROCESS_LOAD_GOAL) * 100, 100);
        complexityProgress.style.width = percent + '%';
        complexityValueDisplay.textContent = Math.floor(cappedLoad);
        
        // Track color changes using data attributes instead of checking the style directly
        if (cappedLoad >= 1700 && complexityProgress.getAttribute('data-color-level') !== '3') {
          complexityProgress.style.backgroundColor = '#FF6B35'; // Orange-red
          complexityProgress.setAttribute('data-color-level', '3');
          showBusinessMessage("process", null, null, businessMessages.process.threshold3);
        } else if (cappedLoad >= 1200 && cappedLoad < 1700 && complexityProgress.getAttribute('data-color-level') !== '2') {
          complexityProgress.style.backgroundColor = '#FF8C00'; // Dark orange
          complexityProgress.setAttribute('data-color-level', '2');
          showBusinessMessage("process", null, null, businessMessages.process.threshold2);
        } else if (cappedLoad >= 500 && cappedLoad < 1200 && complexityProgress.getAttribute('data-color-level') !== '1') {
          complexityProgress.style.backgroundColor = '#FFA500'; // Orange
          complexityProgress.setAttribute('data-color-level', '1');
          showBusinessMessage("process", null, null, businessMessages.process.threshold1);
        } else if (cappedLoad < 500 && complexityProgress.getAttribute('data-color-level') !== '0') {
          // Reset to default color if below threshold
          complexityProgress.style.backgroundColor = '#FFD700'; // Default gold color
          complexityProgress.removeAttribute('data-color-level');
        }
        
        // Check for game completion
        if (cappedLoad >= PROCESS_LOAD_GOAL && !processLoadGoalReached) {
          processLoadGoalReached = true;
          overlayMessage.style.display = 'flex';
        }
      }
      
      // Create enhanced particles effect
      function createParticles(x, y) {
        for (let i = 0; i < 40; i++) { // More particles
          particles.push(new Particle(x, y));
        }
        isEffectActive = true;
      }
      
      // Change head direction
      function changeDirection(headIndex) {
        const head = heads[headIndex];
        const randomAngle = Math.random() * Math.PI * 2;
        head.dirX = Math.cos(randomAngle) * SPEED;
        head.dirY = Math.sin(randomAngle) * SPEED;
      }
      
      // Update wave countdown
      function updateWaveCountdown(deltaTime) {
        // Skip if game is frozen
        if (isGameFrozen) return;
        
        waveCountdown -= deltaTime;
        // Set the new countdown max each time the frequency changes
        waveCountdownMax = 15000 / waveFrequencyFactor;
        const percent = Math.max((waveCountdown / waveCountdownMax) * 100, 0);
        waveCountdownProgress.style.width = percent + '%';
        
        if (waveCountdown <= 0) {
          triggerWave();
          waveCountdown = waveCountdownMax; // Reset countdown with new max value
        }
      }
      
      // Trigger a new wave of obstacles
      function triggerWave() {
        // Always create at least a few obstacles, even on first wave
        const baseObstacles = Math.floor(5 * obstaclesRatio);
        const additionalObstacles = collisionCount < 4 ? 0 : Math.floor(collisionCount / 20);
        const numObstacles = baseObstacles + additionalObstacles;
        
        for (let i = 0; i < numObstacles; i++) {
          const size = customObstacleSize;
          const obstacle = {
            x: Math.random() * (canvas.width - size),
            y: Math.random() * (canvas.height - size),
            width: size,
            height: size,
            vx: (Math.random() * 2 - 1) * customObstacleSpeed,
            vy: (Math.random() * 2 - 1) * customObstacleSpeed
          };
          obstacles.push(obstacle);
        }
        showTooltip("New wave of strategic challenges emerging!");
      }
      
      // Update obstacles
      function updateObstacles() {
        obstacles.forEach(obs => {
          obs.x += obs.vx;
          obs.y += obs.vy;
          
          // Bounce off walls
          if (obs.x < 0 || obs.x + obs.width > canvas.width) {
            obs.vx = -obs.vx;
            obs.x = Math.max(0, Math.min(canvas.width - obs.width, obs.x));
          }
          if (obs.y < 0 || obs.y + obs.height > canvas.height) {
            obs.vy = -obs.vy;
            obs.y = Math.max(0, Math.min(canvas.height - obs.height, obs.y));
          }
        });
      }
      
      // Check head collisions
      function checkHeadCollisions() {
        for (let i = 0; i < heads.length - 1; i++) {
          for (let j = i + 1; j < heads.length; j++) {
            const dx = heads[i].x - heads[j].x;
            const dy = heads[i].y - heads[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < DOT_RADIUS * 2) {
              // Collision detected, change direction of both heads
              changeDirection(i);
              changeDirection(j);
              headCollisionCount++; // Count head collisions
              collisionCount++; // Add to main collision count for process load
              createParticles((heads[i].x + heads[j].x) / 2, (heads[i].y + heads[j].y) / 2);
              showTooltip("Resource conflict detected - redirecting workflow.");
              
              // Check if reached 300 collisions
              if (collisionCount >= 300 && !isGameFrozen) {
                freezeGame();
              }
            }
          }
        }
      }
      
      // Draw game state
      function draw() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw static trails with gradient effect
        staticTrails.forEach(trail => {
          if (trail.length < 2) return;
          
          for (let i = 1; i < trail.length; i++) {
            // Calculate opacity based on position in trail - brighter at the end
            const opacity = i / trail.length;
            
            ctx.beginPath();
            ctx.moveTo(trail[i-1].x, trail[i-1].y);
            ctx.lineTo(trail[i].x, trail[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
          }
        });
        
        // Draw head trails with gradient effect - white at head, darker at the end
        heads.forEach(head => {
          if (head.trail.length < 2) return;
          
          for (let i = 1; i < head.trail.length; i++) {
            // Calculate opacity based on position in trail - brighter near head
            const opacity = (i / head.trail.length);
            
            ctx.beginPath();
            ctx.moveTo(head.trail[i-1].x, head.trail[i-1].y);
            ctx.lineTo(head.trail[i].x, head.trail[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
          }
        });
        
        // Draw obstacles as diamonds - original color
        obstacles.forEach(obstacle => {
          ctx.save();
          const centerX = obstacle.x + obstacle.width / 2;
          const centerY = obstacle.y + obstacle.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(Math.PI / 4);
          // Original gold color
          ctx.fillStyle = "#FF8C00";
          ctx.shadowBlur = 15;
          ctx.shadowColor = "#FF8C00";
          ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
          ctx.shadowBlur = 0;
          ctx.restore();
        });
        
        // Draw particles
        if (isEffectActive) {
          particles.forEach(particle => particle.draw());
        }
        
        // Draw heads
        heads.forEach(head => {
          ctx.beginPath();
          ctx.arc(head.x, head.y, DOT_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = '#ecd404';
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ecd404';
          ctx.fill();
          ctx.shadowBlur = 0;
        });
      }
      
      // Game loop
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }
      
      // Update game state
      function update() {
        // Skip updating if the game is frozen
        if (isGameFrozen) {
          return;
        }
        
        // Update obstacles
        updateObstacles();
        
        // Update heads
        heads.forEach((head, i) => {
          // Move the head
          head.x += head.dirX;
          head.y += head.dirY;
          
          // Bounce off walls - no longer increment collisionCount
          if (head.x - DOT_RADIUS <= 0 || head.x + DOT_RADIUS >= canvas.width) {
            head.dirX = -head.dirX;
            head.x = Math.max(DOT_RADIUS, Math.min(canvas.width - DOT_RADIUS, head.x));
            wallCollisionCount++; // Wall collisions tracked separately
          }
          if (head.y - DOT_RADIUS <= 0 || head.y + DOT_RADIUS >= canvas.height) {
            head.dirY = -head.dirY;
            head.y = Math.max(DOT_RADIUS, Math.min(canvas.height - DOT_RADIUS, head.y));
            wallCollisionCount++; // Wall collisions tracked separately
          }
          
          // Check collisions with obstacles
          obstacles.forEach((obstacle, obsIndex) => {
            if (head.x + DOT_RADIUS > obstacle.x && 
                head.x - DOT_RADIUS < obstacle.x + obstacle.width &&
                head.y + DOT_RADIUS > obstacle.y && 
                head.y - DOT_RADIUS < obstacle.y + obstacle.height) {
              
              // Create a unique collision ID
              const collisionId = `${i}-${obsIndex}`;
              
              // Only count the collision if it hasn't been recorded yet
              if (!headObstacleCollisions.has(collisionId)) {
                headObstacleCollisions.add(collisionId);
                
                // Collision detected
                const angle = Math.atan2(
                  head.y - (obstacle.y + obstacle.height/2), 
                  head.x - (obstacle.x + obstacle.width/2)
                );
                head.dirX = Math.cos(angle) * SPEED;
                head.dirY = Math.sin(angle) * SPEED;
                collisionCount++; // Obstacle collisions still count
                
                // Create particles on obstacle collision
                createParticles(head.x, head.y);
                
                // Check if we've reached 300 collisions and need to freeze the game
                if (collisionCount >= 300 && !isGameFrozen) {
                  freezeGame();
                }
              }
            } else {
              // If not colliding, remove any collision records for this head-obstacle pair
              headObstacleCollisions.delete(`${i}-${obsIndex}`);
            }
          });
          
          // Update trail
          head.trail.push({x: head.x, y: head.y});
          if (head.trail.length > MAX_TRAIL_LENGTH) {
            head.trail.shift();
          }
        });
        
        // Check head collisions
        checkHeadCollisions();
        
        // Update particles
        if (isEffectActive) {
          for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) {
              particles.splice(i, 1);
            }
          }
          if (particles.length === 0) {
            isEffectActive = false;
          }
        }
        
        // Update process load (based only on obstacle collisions and head collisions)
        const processLoad = collisionCount * 50;
        updateProcessLoad(processLoad);
        
        // Update collisions display
        collisionsValue.textContent = collisionCount;
        
        // Update wave countdown
        const now = performance.now();
        const deltaTime = now - lastFrameTime;
        lastFrameTime = now;
        updateWaveCountdown(deltaTime);
      }
      
      // Event listeners
      
      // Container size slider
      containerSizeSlider.addEventListener('input', function() {
        const size = parseInt(this.value);
        containerSizeValue.textContent = size + 'px';
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Show business message
        showBusinessMessage('containerSize', size, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', size);
      });
      
      // Apply container size changes only when sliding is complete
      containerSizeSlider.addEventListener('change', function() {
        const size = parseInt(this.value);
        mazeContainer.style.width = size + 'px';
        mazeContainer.style.height = size + 'px';
        
        // Update canvas size
        canvas.width = size;
        canvas.height = size;
        
        // Ensure heads stay within bounds
        heads.forEach(head => {
          head.x = Math.min(head.x, canvas.width - DOT_RADIUS);
          head.y = Math.min(head.y, canvas.height - DOT_RADIUS);
        });
      });
      
      // Head size slider
      headSizeSlider.addEventListener('input', function() {
        DOT_RADIUS = parseFloat(this.value);
        headSizeValue.textContent = DOT_RADIUS + 'px';
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Show business message
        showBusinessMessage('headSize', DOT_RADIUS, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', DOT_RADIUS);
      });
      
      // Trail Length slider
      trailLengthSlider.addEventListener('input', function() {
        MAX_TRAIL_LENGTH = parseInt(this.value);
        trailLengthValue.textContent = MAX_TRAIL_LENGTH;
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Trim existing trails if needed
        heads.forEach(head => {
          if (head.trail.length > MAX_TRAIL_LENGTH) {
            head.trail = head.trail.slice(head.trail.length - MAX_TRAIL_LENGTH);
          }
        });
        
        staticTrails.forEach((trail, index) => {
          if (trail.length > MAX_TRAIL_LENGTH) {
            staticTrails[index] = trail.slice(trail.length - MAX_TRAIL_LENGTH);
          }
        });
        
        // Show business message
        showBusinessMessage('trailLength', MAX_TRAIL_LENGTH, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', MAX_TRAIL_LENGTH);
      });
      
      // Speed slider
      speedSlider.addEventListener('input', function() {
        SPEED = parseFloat(this.value);
        speedValue.textContent = SPEED;
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Update head speeds
        heads.forEach(head => {
          const angle = Math.atan2(head.dirY, head.dirX);
          head.dirX = Math.cos(angle) * SPEED;
          head.dirY = Math.sin(angle) * SPEED;
        });
        
        // Show business message
        showBusinessMessage('speed', SPEED, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', SPEED);
      });
      
      // Number of heads slider
      numHeadsSlider.addEventListener('input', function() {
        const newNumHeads = parseInt(this.value);
        numHeadsValue.textContent = newNumHeads;
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Add or remove heads as needed
        while (heads.length < newNumHeads) {
          heads.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            dirX: (Math.random() * 2 - 1) * SPEED,
            dirY: (Math.random() * 2 - 1) * SPEED,
            trail: [{ x: canvas.width / 2, y: canvas.height / 2 }]
          });
        }
        
        while (heads.length > newNumHeads) {
          const removed = heads.pop();
          staticTrails.push(removed.trail);
        }
        
        // Show business message
        showBusinessMessage('numHeads', newNumHeads, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', newNumHeads);
      });
      
      // Wave frequency slider
      waveFrequencySlider.addEventListener('input', function() {
        waveFrequencyFactor = parseFloat(this.value);
        waveFrequencyValue.textContent = waveFrequencyFactor.toFixed(1);
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Update the waveCountdownMax
        waveCountdownMax = 15000 / waveFrequencyFactor;
        // Reset the current countdown to match the new max (maintain the same percentage)
        const currentPercent = waveCountdown / (15000 / (waveFrequencyFactor - (this.value - (this.oldValue || this.value))));
        waveCountdown = currentPercent * waveCountdownMax;
        
        // Show business message
        showBusinessMessage('waveFrequency', waveFrequencyFactor, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', waveFrequencyFactor);
      });
      
      // Add an event listener to track the old value
      waveFrequencySlider.addEventListener('mousedown', function() {
        this.oldValue = parseFloat(this.value);
      });
      
      waveFrequencySlider.addEventListener('touchstart', function() {
        this.oldValue = parseFloat(this.value);
      });
      
      // Obstacle size slider
      obstacleSizeSlider.addEventListener('input', function() {
        customObstacleSize = parseInt(this.value);
        obstacleSizeValue.textContent = customObstacleSize + 'px';
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Update existing obstacles
        obstacles.forEach(obs => {
          obs.width = customObstacleSize;
          obs.height = customObstacleSize;
        });
        
        // Show business message
        showBusinessMessage('obstacleSize', customObstacleSize, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', customObstacleSize);
      });
      
      // Obstacle speed slider
      obstacleSpeedSlider.addEventListener('input', function() {
        customObstacleSpeed = parseFloat(this.value);
        obstacleSpeedValue.textContent = customObstacleSpeed.toFixed(1);
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Update existing obstacles
        obstacles.forEach(obs => {
          obs.vx = Math.sign(obs.vx) * customObstacleSpeed;
          obs.vy = Math.sign(obs.vy) * customObstacleSpeed;
        });
        
        // Show business message
        showBusinessMessage('obstacleSpeed', customObstacleSpeed, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', customObstacleSpeed);
      });
      
      // Obstacles per wave ratio slider
      obstaclesPerWaveSlider.addEventListener('input', function() {
        obstaclesRatio = parseFloat(this.value);
        obstaclesPerWaveValue.textContent = obstaclesRatio.toFixed(1);
        
        // Store previous value for smart message
        const previousValue = this.getAttribute('data-prev-value') || this.value;
        
        // Show business message
        showBusinessMessage('obstaclesPerWave', obstaclesRatio, previousValue);
        
        // Update stored value
        this.setAttribute('data-prev-value', obstaclesRatio);
      });
      
      // Clear button
      clearButton.addEventListener('click', function() {
        heads.forEach(head => {
          head.trail = [{ x: head.x, y: head.y }];
        });
        staticTrails = [];
        obstacles = [];
        collisionCount = 0;
        headCollisionCount = 0;
        wallCollisionCount = 0;
        headObstacleCollisions.clear(); // Clear the collision tracking
        waveCountdown = waveCountdownMax;
        updateProcessLoad(0);
        processLoadGoalReached = false;
        overlayMessage.style.display = 'none';
        
        // Reset threshold triggers
        processLoadThresholds.threshold1.triggered = false;
        processLoadThresholds.threshold2.triggered = false;
        processLoadThresholds.threshold3.triggered = false;
        
        // Reset progress bar color
        complexityProgress.style.backgroundColor = '#FFD700';
        complexityProgress.removeAttribute('data-color-level');
        
        // Unfreeze the game if it was frozen
        if (isGameFrozen) {
          isGameFrozen = false;
          
          // Remove the freeze overlay if it exists
          const freezeOverlay = document.getElementById('freezeOverlay');
          if (freezeOverlay) {
            freezeOverlay.remove();
          }
          
          // Reset the business message styling
          businessMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
          businessMessage.style.color = '#FFD700';
          businessMessage.style.fontWeight = 'normal';
          businessMessage.style.borderLeft = 'none';
          businessMessage.style.padding = '5px 15px';
        }
        
        showBusinessMessage('containerSize', null, null, "Process reset complete. System ready for new operational cycle.");
      });
      
      // Restart button
      restartButton.addEventListener('click', function() {
        clearButton.click();
      });
      
      // Canvas click event - only create particles when clicking on heads or obstacles
      canvas.addEventListener('click', function(event) {
        // Skip if the game is frozen
        if (isGameFrozen) return;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        // Check if clicked on a head or near it (improved hit detection)
        for (let i = 0; i < heads.length; i++) {
          const head = heads[i];
          const distance = Math.sqrt(Math.pow(mouseX - head.x, 2) + Math.pow(mouseY - head.y, 2));
          // Increased detection radius for better usability
          if (distance <= DOT_RADIUS * 1.5) {
            changeDirection(i);
            createParticles(head.x, head.y);
            showTooltip("Direction changed - strategic pivot initiated.");
            return;
          }
        }
        
        // Check if clicked on an obstacle - more lenient detection
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          const centerX = obs.x + obs.width / 2;
          const centerY = obs.y + obs.height / 2;
          
          // More generous hit detection for obstacles (square-based)
          if (mouseX >= obs.x - 10 && mouseX <= obs.x + obs.width + 10 &&
              mouseY >= obs.y - 10 && mouseY <= obs.y + obs.height + 10) {
            createParticles(centerX, centerY);
            obstacles.splice(i, 1);
            showTooltip("Obstacle neutralized - path cleared.");
            return;
          }
        }
        
        // Removed particle creation on empty space clicks
      });
      
      // Initialize all sliders with data-prev-value
      const allSliders = document.querySelectorAll('.slider');
      allSliders.forEach(slider => {
        // Store the initial value
        slider.setAttribute('data-prev-value', slider.value);
      });
      
      // Initialize and start the game loop
      initGame();
      gameLoop();
      
      // Show initial business message
      showBusinessMessage('containerSize', null, null, "Process initialized. System ready for operation.");
      
      // Initialize controls state 
      const controlsContainer = document.querySelector('.controls-container');
      controlsContainer.style.display = 'none'; // Start with controls hidden
      
      // Make subsections expanded by default
      sectionHeaders.forEach(header => {
        if (!header.classList.contains('main-controls-header')) {
          const content = header.nextElementSibling;
          const icon = header.querySelector('.collapse-icon');
          content.classList.remove('collapsed');
          icon.classList.remove('collapsed');
        } else {
          const icon = header.querySelector('.collapse-icon');
          icon.classList.add('collapsed');
        }
      });
    });
  </script>
  
  <!-- ElevenLabs Convai Widget Script -->
  <script src="https://elevenlabs.io/convai-widget/index.js" type="text/javascript"></script>
</body>
</html>